\documentclass{book}
\usepackage{graphicx}
\usepackage{lipsum} % For placeholder text, remove in final draft
\usepackage{hyperref}
\usepackage{listings}
\usepackage{array}
\usepackage{geometry}

\title{Fortran Hawatri}
\author{Kia Hawatri}


\begin{document}
\maketitle
\chapter*{Introduction to Fortran 77}

Fortran, short for \textit{Formula Translation}, is one of the oldest high-level programming languages, with its origins dating back to the 1950s. Developed by IBM for scientific and engineering applications, Fortran revolutionized the way numerical computations were performed, enabling researchers and engineers to write programs that were both efficient and portable. Fortran 77, released in 1978, is one of the most influential versions of the language, introducing structured programming features while retaining the simplicity and power that made Fortran a cornerstone of computational science.

\section*{Why Fortran 77?}
Fortran 77 represents a significant milestone in the evolution of programming languages. It introduced many features that are now considered standard in modern programming, such as structured control constructs (\texttt{IF-THEN-ELSE}, \texttt{DO} loops), character string handling, and improved input/output capabilities. Despite its age, Fortran 77 remains relevant today, particularly in legacy systems and fields such as computational physics, climate modeling, and engineering simulations. Its straightforward syntax and focus on numerical computation make it an excellent language for beginners and a powerful tool for experts.

\section*{Who Is This Book For?}
This book is designed for anyone interested in learning Fortran 77, whether you are a student, a researcher, or a professional in a technical field. No prior programming experience is required, as we will start from the basics and gradually build up to more advanced topics. For those already familiar with other programming languages, this book will help you quickly adapt to Fortran's unique features and conventions. By the end of this book, you will have a solid understanding of Fortran 77 and be able to write, debug, and optimize your own programs.

\section*{What Will You Learn?}
In this book, we will cover the following topics:
\begin{itemize}
    \item The history and evolution of Fortran.
    \item Basic syntax and data types in Fortran 77.
    \item Control structures and loops.
    \item Arrays and subroutines.
    \item Input/output operations and file handling.
    \item Common pitfalls and best practices.
    \item Applications of Fortran 77 in scientific computing.
\end{itemize}

\section*{How to Use This Book}
Each chapter is designed to build on the previous one, with clear explanations, practical examples, and exercises to reinforce your understanding. Code snippets are provided throughout the text, and complete programs are available for download from the book's companion website. Whether you are reading this book cover-to-cover or using it as a reference, we encourage you to experiment with the examples and write your own programs to solidify your knowledge.

\section*{A Legacy of Innovation}
Fortran 77 may be a product of its time, but its influence is timeless. By learning Fortran 77, you are not only gaining a valuable skill but also connecting with a rich history of innovation in computing. As you progress through this book, you will discover why Fortran remains a trusted tool for solving some of the world's most complex problems. Welcome to the world of Fortran 77â€”let's begin this journey together.

\chapter{Your First Fortran 77 Program}

\section*{Writing "Hello, World!" in Fortran 77}
Let's start with the classic first program. Create a file named \texttt{hello.f} and type the following:

\begin{verbatim}
C     FORTRAN 77 HELLO WORLD PROGRAM
      PROGRAM HELLOW
C     THIS IS A COMMENT LINE
      WRITE(*,*) 'HELLO WORLD'
      END
\end{verbatim}

\subsection*{Explanation of the Code}
\begin{itemize}
    \item Line 1: Comment line starting with 'C' in column 1
    \item Line 2: \texttt{PROGRAM HELLOW} declares the main program
    \item Line 3: Another comment line
    \item Line 4: \texttt{WRITE(*,*)} outputs text 
    \item Line 5: \texttt{END} marks the program's conclusion
\end{itemize}

\section*{Fortran 77 Coding Rules}

\subsection*{Fixed-Form Formatting}
Fortran 77 uses \textbf{fixed-form source code} with strict column rules:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Columns} & \textbf{Purpose} \\ 
\hline
1-5 & Statement labels, \texttt{FORMAT} identifiers \\
6   & Continuation marker (any character except '0' or space) \\
7-72 & Program statements \\
73+ & Ignored (historical 80-column punch card limit) \\
\hline
\end{tabular}
\end{center}

\subsection*{Key Syntax Rules}
\begin{itemize}
    \item \textbf{Comments}: Start with 'C', '*', or '!' in column 1
    \item \textbf{Continuation}: Place a character in column 6 to continue long lines
    \item \textbf{Labels}: Numeric identifiers (1-99999) in columns 1-5
    \item \textbf{Statements}: Begin in column 7 or later
    \item \textbf{Case Insensitive}: \texttt{WRITE}, \texttt{Write}, and \texttt{write} are equivalent
\end{itemize}

\section*{Spacing Requirements Explained}

\subsection*{Column Layout Example}
\begin{verbatim}
123456789...
C Comment line
     PROGRAM TEST
     WRITE(*,*) 'THIS IS A
    * CONTINUED LINE'
     X = 5.0
     IF (X .GT. 0) THEN
         Y = X**2
     ENDIF
     END
\end{verbatim}

\begin{itemize}
    \item Line 1: Comment (C in column 1)
    \item Line 2: Program starts in column 7
    \item Line 3: Full statement in columns 7-72
    \item Line 4: Continuation character (*) in column 6
    \item Line 7: Code indentation (optional but recommended)
\end{itemize}

\subsection*{Why These Rules Exist?}
The column-based format dates back to punch card era programming:
\begin{itemize}
    \item Columns 1-5: Used for card sequence numbers
    \item Column 6: Continuation indicator for multi-card statements
    \item Columns 73-80: Originally used for card identification numbers
\end{itemize}

\section*{Common Pitfalls to Avoid}
\begin{itemize}
    \item Starting code in column 6 (reserved for continuation)
    \item Using lowercase letters (allowed but not traditional)
    \item Forgetting the continuation marker for long lines
    \item Writing past column 72 (code will be truncated)
    \item Mixing tabs and spaces (use spaces only)
\end{itemize}

\subsection*{Best Practices}
\begin{itemize}
    \item Use uppercase letters for Fortran keywords
    \item Indent code blocks for readability (columns 7-72)
    \item Use comment headers for major sections
    \item Always include \texttt{IMPLICIT NONE} (more on this later)
    \item Test line length with a ruler in your editor
\end{itemize}

\section*{Compiling Your First Program}
Use a Fortran 77 compiler like \texttt{gfortran}:
\begin{verbatim}
gfortran -std=legacy hello.f -o hello
./hello
\end{verbatim}
Output should be: \texttt{HELLO, WORLD!}

\section{Commenting in Fortran 77}

\subsection*{The Art of Documentation}
Comments are essential for writing maintainable code, especially in Fortran 77 where the fixed-format syntax can appear cryptic to modern programmers. Proper commenting helps explain complex algorithms, document assumptions, and make code accessible to future readers.

\subsection*{Comment Syntax}
Fortran 77 has strict rules for comments:
\begin{itemize}
    \item Any line with \texttt{C}, \texttt{*}, or \texttt{!} in \textbf{column 1} becomes a comment
    \item Entire line is ignored by the compiler
    \item No inline comments (unlike modern languages)
    \item Blank lines are allowed but not considered comments
\end{itemize}

\begin{verbatim}
C THIS IS A CLASSIC FORTRAN COMMENT
* THIS VARIANT IS OFTEN USED FOR HEADERS
! SOME COMPILERS SUPPORT THIS (NON-STANDARD)
\end{verbatim}

\subsection*{Effective Commenting Techniques}

\subsubsection*{Basic Example}
\begin{verbatim}
C     ============================================
C     PROGRAM: FLUID_SIMULATION
C     PURPOSE: SOLVE NAVIER-STOKES EQUATIONS
C     AUTHOR:  J. DOE
C     DATE:    2023-08-20
C     ============================================
      PROGRAM FLUID
C     DECLARE VARIABLES
      REAL U(100), V(100), P(100)
C     INITIALIZE ARRAYS
      DO 10 I = 1,100
        U(I) = 0.0
        V(I) = 0.0
10    CONTINUE
*     MAIN SIMULATION LOOP
      DO 20 T = 1,1000
C       UPDATE PRESSURE FIELD
        CALL CALC_PRESSURE(P,U,V)
20    CONTINUE
      END
\end{verbatim}

\subsection*{Commenting Best Practices}
\begin{itemize}
    \item \textbf{Header Blocks}: Use comments at the start of programs/subroutines to describe:
    \begin{itemize}
        \item Program purpose
        \item Input/Output specifications
        \item Author and revision history
        \item Special algorithms used
    \end{itemize}
    
    \item \textbf{Section Dividers}:
    \begin{verbatim}
C     ---- INITIALIZATION PHASE ----
    \end{verbatim}
    
    \item \textbf{Explanatory Comments}:
    \begin{verbatim}
C     APPLY COOLEY-TUKEY FFT ALGORITHM HERE
C     NOTE: ARRAY INDICES START AT 1 PER FORTRAN CONVENTION
    \end{verbatim}
    
    \item \textbf{Warnings}:
    \begin{verbatim}
C     WARNING: DON'T CALL THIS SUBROUTINE RECURSIVELY
C     GLOBAL VARIABLE X MODIFIED IN SECTION 3.2
    \end{verbatim}
\end{itemize}

\subsection*{Common Commenting Mistakes}
\begin{itemize}
    \item \textbf{Improper Alignment}:
    \begin{verbatim}
      C THIS COMMENT WILL CAUSE ERROR (C NOT IN COLUMN 1)
    \end{verbatim}
    
    \item \textbf{Redundant Comments}:
    \begin{verbatim}
C     INCREMENT I
      I = I + 1  (BAD - OBVIOUS OPERATION)
    \end{verbatim}
    
    \item \textbf{Outdated Comments}:
    \begin{verbatim}
C     MAX ARRAY SIZE 50 (ACTUAL SIZE IS 100 IN CODE)
    \end{verbatim}
\end{itemize}

\subsection*{Advanced Commenting Strategies}

\subsubsection*{Commenting Large Blocks}
\begin{verbatim}
C     ================================================
C     SUBROUTINE: MATRIX_SOLVER
C     PURPOSE:    SOLVE LINEAR SYSTEM AX=B
C     METHOD:     GAUSSIAN ELIMINATION WITH PIVOTING
C     ARGUMENTS:
C       A - COEFFICIENT MATRIX (N x N)
C       B - RIGHT-HAND SIDE VECTOR (N)
C       X - SOLUTION VECTOR (OUTPUT)
C       N - SYSTEM DIMENSION
C     ================================================
      SUBROUTINE MATRIX_SOLVER(A,B,X,N)
      DIMENSION A(N,N), B(N), X(N)
C     ... implementation ...
      END
\end{verbatim}

\subsubsection*{Temporary Code Exclusion}
\begin{verbatim}
C     DEBUGGING CODE - DISABLE FOR PRODUCTION
CC    WRITE(*,*) 'CURRENT VALUE:', X
C     CALL DEBUG_ROUTINE
\end{verbatim}

\subsection*{Historical Context}
The column-based commenting system originated from:
\begin{itemize}
    \item Punch card era physical constraints
    \item Need for quick visual identification of comments
    \item Limited screen space on early text terminals
\end{itemize}

\subsection*{Modern Considerations}
While maintaining Fortran 77 compatibility:
\begin{itemize}
    \item Many modern editors support syntax highlighting
    \item Consider using lowercase for better readability:
    \begin{verbatim}
c     Mixed-case comments often read better
c     Than all-uppercase text blocks
    \end{verbatim}
    \item Use version control instead of comment-based revision tracking
\end{itemize}

\section{Variables in Fortran 77}

\subsection*{Variable Types}
Fortran 77 supports these fundamental data types:
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Type} & \textbf{Description} & \textbf{Example Values} \\ 
\hline
\texttt{INTEGER} & Whole numbers & -3, 0, 42 \\
\texttt{REAL} & Single-precision floating point & 3.14, -0.001 \\
\texttt{DOUBLE PRECISION} & Double-precision floating point & 1.23456D+08 \\
\texttt{CHARACTER} & Text/String & 'Hello', 'A' \\
\texttt{LOGICAL} & Boolean values & \texttt{.TRUE.}, \texttt{.FALSE.} \\
\texttt{COMPLEX} & Complex numbers & (1.0, -2.5) \\
\hline
\end{tabular}
\end{center}

\subsection*{Declaration Syntax}
Variables must be declared at the start of the program/subroutine:
\begin{verbatim}
      PROGRAM VARIABLES
      INTEGER COUNT, INDEX
      REAL TEMP, PRESSURE
      CHARACTER*20 NAME
      LOGICAL FLAG
      DOUBLE PRECISION PI
      COMPLEX WAVE
\end{verbatim}

\subsection*{Naming Rules}
\begin{itemize}
    \item Maximum 6 characters (truncated if longer)
    \item Must start with a letter (A-Z)
    \item Subsequent characters: letters/digits (0-9)
    \item Case insensitive: \texttt{Var} = \texttt{VAR} = \texttt{var}
    \item Avoid reserved words: \texttt{PROGRAM}, \texttt{END}, etc.
\end{itemize}

\subsection*{Type-Specific Examples}

\subsubsection*{INTEGER}
\begin{verbatim}
      PROGRAM INT_EX
      INTEGER AGE, YEAR
      WRITE(*,*) 'ENTER BIRTH YEAR:'
      READ(*,*) YEAR
      AGE = 2023 - YEAR
      WRITE(*,*) 'AGE:', AGE
      STOP
      END
\end{verbatim}

\subsubsection*{REAL}
\begin{verbatim}
      PROGRAM REAL_EX
      REAL TEMP_C, TEMP_F
      WRITE(*,*) 'ENTER FAHRENHEIT TEMP:'
      READ(*,*) TEMP_F
      TEMP_C = (TEMP_F - 32.0) * 5.0/9.0
      WRITE(*,*) 'CELSIUS:', TEMP_C
      STOP
      END
\end{verbatim}

\subsubsection*{DOUBLE PRECISION}
\begin{verbatim}
      PROGRAM DOUBLE_EX
      DOUBLE PRECISION PI
      PI = 4.0D0 * ATAN(1.0D0)
      WRITE(*,*) 'PI =', PI
      STOP
      END
\end{verbatim}

\subsubsection*{CHARACTER}
\begin{verbatim}
      PROGRAM CHAR_EX
      CHARACTER*15 CITY
      WRITE(*,*) 'ENTER YOUR CITY:'
      READ(*,*) CITY
      WRITE(*,*) 'CITY:', CITY
      STOP
      END
\end{verbatim}

\subsubsection*{LOGICAL}
\begin{verbatim}
      PROGRAM LOG_EX
      LOGICAL FLAG
      FLAG = .TRUE.
      IF (FLAG) THEN
          WRITE(*,*) 'CONDITION IS TRUE'
      ENDIF
      STOP
      END
\end{verbatim}

\subsubsection*{COMPLEX}
\begin{verbatim}
      PROGRAM COMPLEX_EX
      COMPLEX Z
      Z = (3.0, 4.0)  ! 3 + 4i
      WRITE(*,*) 'MAGNITUDE:', ABS(Z)
      STOP
      END
\end{verbatim}

\subsection*{Type Conversion}
Convert between types explicitly:
\begin{verbatim}
      REAL X
      INTEGER N
      X = 3.14
      N = INT(X)      ! N becomes 3
      X = REAL(N)     ! X becomes 3.0
\end{verbatim}

\subsection*{Common Mistakes}
\begin{itemize}
    \item \textbf{Implicit Typing}: Variables starting with I-N are integers by default
    \begin{verbatim}
      K = 2.5  ! Becomes INTEGER 2 (no error!)
    \end{verbatim}
    
    \item \textbf{Solution}: Always declare \texttt{IMPLICIT NONE} first
    \begin{verbatim}
      PROGRAM SAFE
      IMPLICIT NONE
      \end{verbatim}
    
    \item \textbf{Truncation}:
    \begin{verbatim}
      CHARACTER*5 NAME = 'LONDON'  ! Becomes 'LONDO'
    \end{verbatim}
    
    \item \textbf{Precision Loss}:
    \begin{verbatim}
      REAL PI = 3.1415926535  ! Stored as 3.141593
    \end{verbatim}
\end{itemize}

\subsection*{Best Practices}
\begin{itemize}
    \item Always use \texttt{IMPLICIT NONE} to force declarations
    \item Choose meaningful names: \texttt{VOLTAGE} vs \texttt{V}
    \item Use \texttt{DOUBLE PRECISION} for scientific calculations
    \item Initialize variables before use
    \item Comment on variable purposes in complex programs
\end{itemize}

\subsection*{Storage Considerations}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Type} & \textbf{Typical Size} \\ 
\hline
\texttt{INTEGER} & 4 bytes \\
\texttt{REAL} & 4 bytes \\
\texttt{DOUBLE PRECISION} & 8 bytes \\
\texttt{CHARACTER*n} & n bytes \\
\texttt{LOGICAL} & 4 bytes (usually) \\
\texttt{COMPLEX} & 8 bytes (2Ã—4-byte reals) \\
\hline
\end{tabular}
\end{center}

\section{User Input and Variable Handling}

\subsection*{Basic Input-Process-Output Workflow}
Fortran 77 programs typically follow this pattern:
\begin{enumerate}
    \item Prompt user with \texttt{WRITE(*,*)}
    \item Read input with \texttt{READ(*,*)}
    \item Process data
    \item Display results with \texttt{WRITE(*,*)}
\end{enumerate}

\subsection*{Single Variable Example}
\begin{verbatim}
C     PROGRAM: AGE_CHECKER
C     PURPOSE: DEMONSTRATE SINGLE VARIABLE INPUT
      PROGRAM AGE_CHECK
      INTEGER AGE
C     DISPLAY PROMPT
      WRITE(*,*) 'ENTER YOUR AGE:'
C     READ INTEGER INPUT
      READ(*,*) AGE
C     DISPLAY RESULT
      WRITE(*,*) 'IN 10 YEARS YOU WILL BE:', AGE + 10
      STOP
      END
\end{verbatim}

\subsection*{Multiple Variables Example}
\begin{verbatim}
C     PROGRAM: RECTANGLE_AREA
C     INPUT: LENGTH AND WIDTH
C     OUTPUT: CALCULATED AREA
      PROGRAM RECT_AREA
      REAL LENGTH, WIDTH, AREA
C     GET DIMENSIONS
      WRITE(*,*) 'ENTER LENGTH AND WIDTH (SEPARATE BY SPACE):'
      READ(*,*) LENGTH, WIDTH
C     CALCULATE AND DISPLAY
      AREA = LENGTH * WIDTH
      WRITE(*,*) 'AREA OF RECTANGLE:', AREA
      STOP
      END
\end{verbatim}

\subsection*{Type-Specific Input Handling}

\subsubsection*{Character Input}
\begin{verbatim}
C     PROGRAM: GREETER
C     DEMONSTRATES STRING HANDLING
      PROGRAM GREETER
      CHARACTER*20 NAME
C     GET USER NAME
      WRITE(*,*) 'ENTER YOUR NAME:'
      READ(*,*) NAME
C     DISPLAY GREETING
      WRITE(*,*) 'HELLO, ', TRIM(NAME), '! WELCOME!'
      STOP
      END
\end{verbatim}

\subsubsection*{Logical Input}
\begin{verbatim}
C     PROGRAM: LOGIC_TEST
C     SHOWS BOOLEAN INPUT HANDLING
      PROGRAM LOGTEST
      LOGICAL FLAG
C     GET TRUE/FALSE INPUT
      WRITE(*,*) 'ENTER .TRUE. OR .FALSE.:'
      READ(*,*) FLAG
C     DISPLAY NEGATION
      WRITE(*,*) 'NEGATED VALUE:', .NOT.FLAG
      STOP
      END
\end{verbatim}

\subsection*{Input Validation}
\begin{verbatim}
C     PROGRAM: TEMP_CONVERTER
C     WITH BASIC ERROR CHECKING
      PROGRAM TEMPCONV
      REAL FAHREN
C     INPUT LOOP
10    WRITE(*,*) 'ENTER TEMPERATURE (-200 TO 200 F):'
      READ(*,*) FAHREN
      IF (FAHREN .LT. -200 .OR. FAHREN .GT. 200) THEN
          WRITE(*,*) 'INVALID INPUT! TRY AGAIN.'
          GOTO 10
      ENDIF
C     CONVERT TO CELSIUS
      CELSIUS = (FAHREN - 32.0) * 5.0/9.0
      WRITE(*,*) 'CELSIUS TEMPERATURE:', CELSIUS
      STOP
      END
\end{verbatim}

\subsection*{Troubleshooting Input Issues}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Issue} & \textbf{Solution} \\ 
\hline
User enters text for numeric input & Program crashes - add error handling (see Ch. 7) \\
\hline
Multiple values without spaces & Use comma/space separation: \texttt{10,20} not \texttt{10 20} \\
\hline
String longer than declaration & Truncated to variable length \\
\hline
Mixing data types & Ensure \texttt{READ} matches variable types \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
    \item Always include clear prompts before \texttt{READ} statements
    \item Use descriptive variable names
    \item Initialize variables before use
    \item Add comments explaining non-obvious input requirements
    \item Test with boundary values and invalid inputs
    \item Use \texttt{TRIM()} for character variables in output
\end{itemize}

\subsection*{Complete Example with Comments}
\begin{verbatim}
C     PROGRAM: EMPLOYEE_RECORD
C     PURPOSE: DEMONSTRATE MIXED DATA TYPE INPUT
      PROGRAM EMP_REC
      CHARACTER*15 NAME
      INTEGER AGE
      REAL SALARY
      LOGICAL FULLTIME

C     GET EMPLOYEE DETAILS
      WRITE(*,*) 'ENTER EMPLOYEE NAME:'
      READ(*,*) NAME
      WRITE(*,*) 'ENTER AGE (YEARS):'
      READ(*,*) AGE
      WRITE(*,*) 'ENTER ANNUAL SALARY:'
      READ(*,*) SALARY
      WRITE(*,*) 'FULL-TIME? (.TRUE./.FALSE.):'
      READ(*,*) FULLTIME

C     DISPLAY SUMMARY
      WRITE(*,*) 'EMPLOYEE DETAILS:'
      WRITE(*,*) 'NAME:    ', TRIM(NAME)
      WRITE(*,*) 'AGE:     ', AGE
      WRITE(*,*) 'SALARY:  $', SALARY
      WRITE(*,*) 'FULL-TIME: ', FULLTIME

      STOP
      END
\end{verbatim}

\subsection*{Notes on Input Formatting}
\begin{itemize}
    \item Use free-format \texttt{READ(*,*)} for simple programs
    \item Numeric input accepts:
    \begin{itemize}
        \item Integers: \texttt{42}, \texttt{-15}
        \item Reals: \texttt{3.14}, \texttt{.5}, \texttt{6.02E23}
    \end{itemize}
    \item Logical input requires \texttt{.TRUE.} or \texttt{.FALSE.}
    \item Character input stops at first whitespace (use \texttt{READ} with format for spaces)
\end{itemize}

\subsection*{Compilation \& Testing Tip}
\begin{verbatim}
# Compile with strict Fortran 77 checking
gfortran -std=legacy -Wall input_example.f -o demo
\end{verbatim}

\section{Arithmetic Operations in Fortran 77}

\subsection*{Fundamental Arithmetic Operators}
Fortran 77 supports standard mathematical operations with this precedence:
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Operator} & \textbf{Operation} & \textbf{Example} \\ 
\hline
\texttt{**} & Exponentiation & \texttt{X**2} \\
\texttt{*} & Multiplication & \texttt{A * B} \\
\texttt{/} & Division & \texttt{Y / Z} \\
\texttt{+} & Addition & \texttt{C + D} \\
\texttt{-} & Subtraction & \texttt{M - N} \\
\hline
\end{tabular}
\end{center}

\subsection*{Basic Operation Examples}

\subsubsection*{Simple Calculations}
\begin{verbatim}
C     PROGRAM: BASIC_MATH
C     DEMONSTRATES FUNDAMENTAL OPERATIONS
      PROGRAM CALC
      REAL X, Y, RESULT
      
      X = 10.0
      Y = 3.0
      
      RESULT = X + Y
      WRITE(*,*) 'SUM:      ', RESULT
      
      RESULT = X - Y
      WRITE(*,*) 'DIFFERENCE:', RESULT
      
      RESULT = X * Y
      WRITE(*,*) 'PRODUCT:  ', RESULT
      
      RESULT = X / Y
      WRITE(*,*) 'QUOTIENT: ', RESULT
      
      RESULT = X**2 + Y**3
      WRITE(*,*) 'XÂ² + YÂ³:  ', RESULT
      
      STOP
      END
\end{verbatim}

\subsection*{Operator Precedence}
Operations follow PEMDAS rules (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction):

\begin{verbatim}
C     PROGRAM: PRECEDENCE
C     SHOWS ORDER OF OPERATIONS
      PROGRAM ORDER
      REAL A, B, C, RESULT
      
      A = 2.0
      B = 3.0
      C = 4.0
      
C     EQUIVALENT TO: (A + B) * C
      RESULT = A + B * C
      WRITE(*,*) 'WITHOUT PARENTHESES:', RESULT
      
C     EXPLICIT ORDERING
      RESULT = (A + B) * C
      WRITE(*,*) 'WITH PARENTHESES:   ', RESULT
      
      STOP
      END
\end{verbatim}

\subsection*{Mixed-Type Operations}
Fortran automatically converts types during operations:

\begin{verbatim}
C     PROGRAM: TYPE_MIX
C     DEMONSTRATES INTEGER/REAL INTERACTIONS
      PROGRAM TYPEMIX
      INTEGER I
      REAL R
      DOUBLE PRECISION D
      
      I = 5
      R = 2.5
      D = 1.0D0
      
C     INTEGER + REAL = REAL
      WRITE(*,*) '5 + 2.5 =', I + R
      
C     REAL / INTEGER = REAL
      WRITE(*,*) '2.5 / 2 =', R / 2
      
C     DOUBLE PRECISION OPERATION
      D = D / 3.0D0
      WRITE(*,*) '1/3 (DP):', D
      
      STOP
      END
\end{verbatim}

\subsection*{Common Mathematical Functions}
Fortran 77 provides intrinsic functions:

\begin{verbatim}
C     PROGRAM: MATH_FUNCS
C     SHOWS BUILT-IN MATHEMATICAL FUNCTIONS
      PROGRAM MFUNCS
      REAL X, Y, ANGLE
      
      X = 16.0
      Y = 2.5
      ANGLE = 45.0
      
C     SQUARE ROOT
      WRITE(*,*) 'SQRT(16):    ', SQRT(X)
      
C     EXPONENTIAL
      WRITE(*,*) 'EXP(2.5):    ', EXP(Y)
      
C     NATURAL LOG
      WRITE(*,*) 'LOG(2.5):    ', LOG(Y)
      
C     TRIG FUNCTIONS (IN RADIANS)
      WRITE(*,*) 'SIN(45Â°):    ', SIN(ANGLE * 3.14159 / 180.0)
      
C     ABSOLUTE VALUE
      WRITE(*,*) 'ABS(-2.5):   ', ABS(-Y)
      
C     MODULO OPERATION
      WRITE(*,*) 'MOD(17,5):   ', MOD(17, 5)
      
      STOP
      END
\end{verbatim}

\subsection*{Complete Example: Quadratic Equation}
\begin{verbatim}
C     PROGRAM: QUADRATIC_SOLVER
C     SOLVES AXÂ² + BX + C = 0
      PROGRAM QUAD
      REAL A, B, C, DISC, X1, X2
      
C     GET COEFFICIENTS
      WRITE(*,*) 'ENTER A, B, C (SEPARATED BY SPACES):'
      READ(*,*) A, B, C
      
C     CALCULATE DISCRIMINANT
      DISC = B**2 - 4.0*A*C
      
C     HANDLE COMPLEX ROOTS
      IF (DISC .LT. 0.0) THEN
          WRITE(*,*) 'COMPLEX ROOTS!'
          STOP
      ENDIF
      
C     CALCULATE ROOTS
      X1 = (-B + SQRT(DISC)) / (2.0*A)
      X2 = (-B - SQRT(DISC)) / (2.0*A)
      
      WRITE(*,*) 'ROOTS ARE:', X1, 'AND', X2
      STOP
      END
\end{verbatim}

\subsection*{Common Arithmetic Pitfalls}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Issue} & \textbf{Solution} \\ 
\hline
Integer division: \texttt{5/2 = 2} & Use real numbers: \texttt{5.0/2.0 = 2.5} \\
\hline
Overflow with large exponents & Use \texttt{DOUBLE PRECISION} variables \\
\hline
Division by zero & Add validation checks before division \\
\hline
Mixing precedence & Use parentheses for clarity \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
    \item Use parentheses for complex expressions
    \item Avoid integer division when fractional results are needed
    \item Use \texttt{DOUBLE PRECISION} for sensitive calculations
    \item Check for division by zero and negative roots
    \item Use meaningful variable names (\texttt{VOLUME} vs \texttt{V})
\end{itemize}

\subsection*{Troubleshooting Table}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Error Message} & \textbf{Meaning} \\ 
\hline
\texttt{Arithmetic overflow} & Result exceeds variable type capacity \\
\hline
\texttt{Divided by zero} & Attempted division with zero denominator \\
\hline
\texttt{Type mismatch} & Mixed incompatible types without conversion \\
\hline
\end{tabular}
\end{center}

\subsection*{Compilation Note}
\begin{verbatim}
# Enable all warnings for arithmetic checks
gfortran -std=legacy -Wall -Wextra math_example.f -o demo
\end{verbatim}

\section{Type Conversion in Fortran 77}

\subsection*{Implicit vs. Explicit Conversion}
Fortran 77 allows both implicit (automatic) and explicit (programmer-controlled) type conversion. While convenient, implicit conversion can lead to subtle bugs, making explicit conversion the safer approach.

\subsection*{Implicit Type Conversion}
\begin{itemize}
    \item \textbf{Mixed-Type Operations}: Fortran automatically promotes types in expressions
    \begin{verbatim}
      INTEGER I = 5
      REAL R = 2.5
      RESULT = I + R  ! I is converted to REAL (5.0) first
    \end{verbatim}
    
    \item \textbf{Assignment Conversion}: Right-hand side converted to left-hand side type
    \begin{verbatim}
      REAL X
      X = 3   ! Integer 3 converted to REAL 3.0
    \end{verbatim}
    
    \item \textbf{Default Typing}: Variables starting with I-N are INTEGER by default
    \begin{verbatim}
      K = 2.7  ! K is INTEGER â†’ becomes 2 (truncation occurs)
    \end{verbatim}
\end{itemize}

\subsection*{Explicit Type Conversion Functions}
Fortran provides intrinsic functions for controlled conversion:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Function} & \textbf{Purpose} \\ 
\hline
\texttt{INT(X)} & Convert to \texttt{INTEGER} (truncates) \\
\texttt{REAL(X)} & Convert to single-precision \texttt{REAL} \\
\texttt{DBLE(X)} & Convert to \texttt{DOUBLE PRECISION} \\
\texttt{CMPLX(X,Y)} & Create \texttt{COMPLEX} number (X + Yi) \\
\texttt{ICHAR(C)} & Convert character to ASCII code \\
\texttt{CHAR(I)} & Convert ASCII code to character \\
\hline
\end{tabular}
\end{center}

\subsection*{Code Examples}

\subsubsection*{Integer to Real}
\begin{verbatim}
      PROGRAM INT2REAL
      INTEGER COUNT
      REAL AVERAGE
      COUNT = 7
C     EXPLICIT CONVERSION TO AVOID INTEGER DIVISION
      AVERAGE = REAL(COUNT) / 2.0
      WRITE(*,*) 'AVERAGE:', AVERAGE  ! Output: 3.5
      STOP
      END
\end{verbatim}

\subsubsection*{Real to Integer}
\begin{verbatim}
      PROGRAM REAL2INT
      REAL TEMP = 98.6
      INTEGER ITEMP
C     TRUNCATE DECIMAL PART
      ITEMP = INT(TEMP)
      WRITE(*,*) 'INTEGER TEMP:', ITEMP  ! Output: 98
      STOP
      END
\end{verbatim}

\subsubsection*{Double Precision Conversion}
\begin{verbatim}
      PROGRAM DBLE_CONV
      REAL PI_SINGLE = 3.14159
      DOUBLE PRECISION PI_DOUBLE
C     PRESERVE PRECISION
      PI_DOUBLE = DBLE(PI_SINGLE)
      WRITE(*,*) 'DOUBLE PI:', PI_DOUBLE
      STOP
      END
\end{verbatim}

\subsection*{Character Conversions}
\begin{verbatim}
      PROGRAM CHAR_CONV
      CHARACTER C
      INTEGER ASCII
C     CHARACTER TO ASCII
      C = 'A'
      ASCII = ICHAR(C)
      WRITE(*,*) 'ASCII CODE:', ASCII  ! Output: 65
      
C     ASCII TO CHARACTER
      C = CHAR(66)
      WRITE(*,*) 'CHARACTER:', C  ! Output: B
      STOP
      END
\end{verbatim}

\subsection*{Common Pitfalls}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Issue} & \textbf{Solution} \\ 
\hline
\texttt{REAL(5/2) = 2.0} (integer division first) & Use \texttt{REAL(5)/2.0 = 2.5} \\
\hline
\texttt{INT(3.999) = 3} (truncation) & Use \texttt{NINT()} for rounding \\
\hline
Implicit realâ†’integer conversion & Always use \texttt{INT()} explicitly \\
\hline
Precision loss in realâ†’double & Use \texttt{DBLE()} on literals: \texttt{DBLE(0.1D0)} \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
    \item Always use \texttt{IMPLICIT NONE} to disable automatic typing
    \item Perform explicit conversions for clarity
    \item Use \texttt{NINT()} instead of \texttt{INT()} for rounding
    \item Avoid mixing types in complex expressions
    \item Comment non-obvious conversions
\end{itemize}

\subsection*{Advanced Conversion: Complex Numbers}
\begin{verbatim}
      PROGRAM COMPLEX_CONV
      COMPLEX Z
      REAL X, Y
      X = 3.0
      Y = 4.0
C     CREATE COMPLEX FROM REALS
      Z = CMPLX(X, Y)
      WRITE(*,*) 'COMPLEX:', Z  ! Output: (3.0,4.0)
      STOP
      END
\end{verbatim}

\subsection*{Type Conversion Rules}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Conversion} & \textbf{Behavior} \\ 
\hline
\texttt{REAL â†’ INTEGER} & Truncates decimal (no rounding) \\
\texttt{INTEGER â†’ REAL} & Exact conversion \\
\texttt{REAL â†’ DOUBLE} & Preserves precision \\
\texttt{DOUBLE â†’ REAL} & Truncates to single precision \\
\texttt{CHARACTER â†’ INTEGER} & ASCII code conversion \\
\hline
\end{tabular}
\end{center}

\subsection*{Why Explicit Conversion Matters}
\begin{verbatim}
C DANGEROUS IMPLICIT CONVERSION EXAMPLE
      PROGRAM DANGER
      IMPLICIT NONE
      REAL A = 5.0
      INTEGER B = 2
      WRITE(*,*) A/B  ! = 2.5 (GOOD)
      
      REAL C = 5
      INTEGER D = 2
      WRITE(*,*) C/D  ! = 2.5 (STILL GOOD? DEPENDS ON COMPILER!)
      STOP
      END
\end{verbatim}

\subsection*{Final Recommendations}
\begin{itemize}
    \item Use \texttt{REAL()} when mixing integers and reals
    \item Prefer \texttt{DBLE()} for high-precision calculations
    \item Always validate ranges before narrowing conversions
    \item Test conversions at boundary values
\end{itemize}

\section{Exercises}

\subsection*{Problem 1: Basic Program Structure}
Write a Fortran 77 program that:
\begin{itemize}
    \item Prints "MY FIRST FORTRAN PROGRAM"
    \item Includes proper comments
    \item Follows fixed-format rules
\end{itemize}
\textit{Sample Output:}
\begin{verbatim}
MY FIRST FORTRAN PROGRAM
\end{verbatim}

\subsection*{Problem 2: Variable Declaration}
Create a program that:
\begin{itemize}
    \item Declares an integer (AGE = 25)
    \item Declares a real number (PI = 3.14159)
    \item Declares a character (INITIAL = 'A')
    \item Prints all variables with labels
\end{itemize}

\subsection*{Problem 3: User Input Handling}
Write a program that:
\begin{itemize}
    \item Asks for user's name and birth year
    \item Calculates approximate age
    \item Prints formatted message
\end{itemize}
\textit{Sample Input/Output:}
\begin{verbatim}
ENTER YOUR NAME: JOHN
ENTER BIRTH YEAR: 1998
HELLO JOHN, YOU ARE ABOUT 25 YEARS OLD.
\end{verbatim}

\subsection*{Problem 4: Arithmetic Operations}
Create a program to calculate kinetic energy:
\[ KE = \frac{1}{2}mv^2 \]
Where:
\begin{itemize}
    \item Mass (m) = 10.5 kg
    \item Velocity (v) = 5.2 m/s
    \item Print result with description
\end{itemize}

\subsection*{Problem 5: Mixed-Type Calculation}
Write a program that:
\begin{itemize}
    \item Declares integer HOURS = 8
    \item Declares real RATE = 12.50
    \item Calculates total pay (HOURS * RATE)
    \item Explain why result is real
\end{itemize}

\subsection*{Problem 6: Explicit Type Conversion}
Create a program that:
\begin{itemize}
    \item Takes a real number input (e.g., 7.89)
    \item Converts to integer using INT()
    \item Converts to nearest integer using NINT()
    \item Prints both results
\end{itemize}

\subsection*{Problem 7: Temperature Conversion}
Write a program that:
\begin{itemize}
    \item Reads Celsius temperature
    \item Converts to Fahrenheit using:
    \[ F = \frac{9}{5}C + 32 \]
    \item Prints both temperatures
\end{itemize}

\subsection*{Problem 8: Geometric Calculations}
Develop a program to calculate:
\begin{itemize}
    \item Circle circumference \( C = 2\pi r \)
    \item Sphere volume \( V = \frac{4}{3}\pi r^3 \)
    \item Use radius = 5.0
    \item Print both results
\end{itemize}

\subsection*{Problem 9: Character Manipulation}
Create a program that:
\begin{itemize}
    \item Takes a character input
    \item Prints its ASCII code
    \item Takes an integer input (65-90)
    \item Prints corresponding character
\end{itemize}

\subsection*{Problem 10: Precision Demonstration}
Write a program that:
\begin{itemize}
    \item Calculates \( \frac{1}{3} \) as REAL
    \item Calculates \( \frac{1}{3} \) as DOUBLE PRECISION
    \item Prints both results
    \item Explain the difference
\end{itemize}

\subsection*{Challenge Problem: Unit Converter}
Create an interactive program that:
\begin{itemize}
    \item Asks user for length in kilometers
    \item Converts to miles (1 km = 0.621371 miles)
    \item Prints both values
    \item Uses proper type conversions
\end{itemize}
\textit{Bonus: Add error checking for negative inputs}

\section{Exercise Answers}

\subsection*{Problem 1: Basic Program Structure}
\begin{verbatim}
C     PROBLEM 1 SOLUTION
C     PURPOSE: DEMONSTRATE BASIC PROGRAM STRUCTURE
      PROGRAM FIRST
C     OUTPUT MESSAGE
      WRITE(*,*) 'MY FIRST FORTRAN PROGRAM'
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
\begin{itemize}
    \item Comments start with 'C' in column 1
    \item Program statement begins in column 7
    \item WRITE statement uses list-directed output
    \item STOP terminates execution, END concludes program
\end{itemize}

\subsection*{Problem 2: Variable Declaration}
\begin{verbatim}
C     PROBLEM 2 SOLUTION
      PROGRAM VARDEC
      INTEGER AGE
      REAL PI
      CHARACTER INITIAL
C     INITIALIZE VALUES
      AGE = 25
      PI = 3.14159
      INITIAL = 'A'
C     OUTPUT RESULTS
      WRITE(*,*) 'AGE:    ', AGE
      WRITE(*,*) 'PI:     ', PI
      WRITE(*,*) 'INITIAL:', INITIAL
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
\begin{itemize}
    \item Variables declared before executable statements
    \item Different data types require specific declarations
    \item Character literals enclosed in single quotes
\end{itemize}

\subsection*{Problem 3: User Input Handling}
\begin{verbatim}
C     PROBLEM 3 SOLUTION
      PROGRAM AGE_CALC
      CHARACTER*20 NAME
      INTEGER B_YEAR, AGE
C     GET INPUT
      WRITE(*,*) 'ENTER YOUR NAME:'
      READ(*,*) NAME
      WRITE(*,*) 'ENTER BIRTH YEAR:'
      READ(*,*) B_YEAR
C     CALCULATE AGE
      AGE = 2023 - B_YEAR
C     OUTPUT RESULTS
      WRITE(*,*) 'HELLO ', TRIM(NAME), ', YOU ARE ABOUT ', AGE, ' YEARS OLD.'
      STOP
      END
\end{verbatim}
\textbf{Notes:}
\begin{itemize}
    \item CHARACTER*20 reserves 20 characters for the name
    \item TRIM() removes trailing spaces from the name
    \item Input order must match variable types
\end{itemize}

\subsection*{Problem 4: Arithmetic Operations}
\begin{verbatim}
C     PROBLEM 4 SOLUTION
      PROGRAM KINETIC
      REAL MASS, VEL, KE
C     INITIALIZE VALUES
      MASS = 10.5
      VEL = 5.2
C     CALCULATE KINETIC ENERGY
      KE = 0.5 * MASS * VEL**2
C     OUTPUT RESULT
      WRITE(*,*) 'KINETIC ENERGY:', KE, 'JOULES'
      STOP
      END
\end{verbatim}
\textbf{Formula Implementation:}
\[ KE = \frac{1}{2} \times 10.5 \times (5.2)^2 \]
\begin{itemize}
    \item Exponentiation operator ** used for velocity squared
    \item Operator precedence handled correctly
\end{itemize}

\subsection*{Problem 5: Mixed-Type Calculation}
\begin{verbatim}
C     PROBLEM 5 SOLUTION
      PROGRAM PAYCALC
      INTEGER HOURS
      REAL RATE, TOTAL
C     INITIALIZE VALUES
      HOURS = 8
      RATE = 12.50
C     CALCULATE PAY
      TOTAL = HOURS * RATE
C     OUTPUT RESULT
      WRITE(*,*) 'TOTAL PAY: $', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Type Conversion:}
\begin{itemize}
    \item Integer HOURS promoted to real during multiplication
    \item Result TOTAL is real (100.0 instead of 100)
    \item Explicit conversion not needed but recommended
\end{itemize}

\subsection*{Problem 6: Explicit Type Conversion}
\begin{verbatim}
C     PROBLEM 6 SOLUTION
      PROGRAM CONVERT
      REAL NUM
      INTEGER ITRUNC, IROUND
C     GET INPUT
      WRITE(*,*) 'ENTER A REAL NUMBER:'
      READ(*,*) NUM
C     CONVERT
      ITRUNC = INT(NUM)
      IROUND = NINT(NUM)
C     OUTPUT RESULTS
      WRITE(*,*) 'TRUNCATED:', ITRUNC
      WRITE(*,*) 'ROUNDED:  ', IROUND
      STOP
      END
\end{verbatim}
\textbf{Differences:}
\begin{itemize}
    \item INT(7.89) â†’ 7 (truncation)
    \item NINT(7.89) â†’ 8 (rounding)
    \item Always use NINT() for proper rounding
\end{itemize}

\subsection*{Problem 7: Temperature Conversion}
\begin{verbatim}
C     PROBLEM 7 SOLUTION
      PROGRAM TEMPCONV
      REAL CELS, FAHR
C     GET INPUT
      WRITE(*,*) 'ENTER TEMPERATURE IN CELSIUS:'
      READ(*,*) CELS
C     CONVERT
      FAHR = (9.0/5.0)*CELS + 32.0
C     OUTPUT RESULTS
      WRITE(*,*) CELS, 'C =', FAHR, 'F'
      STOP
      END
\end{verbatim}
\textbf{Formula Notes:}
\begin{itemize}
    \item Use 9.0/5.0 instead of 9/5 to force real division
    \item Operator precedence handled with parentheses
\end{itemize}

\subsection*{Problem 8: Geometric Calculations}
\begin{verbatim}
C     PROBLEM 8 SOLUTION
      PROGRAM GEOMETRY
      REAL R, CIRCUM, VOLUME
      PARAMETER (PI = 3.14159)
C     INITIALIZE RADIUS
      R = 5.0
C     CALCULATIONS
      CIRCUM = 2 * PI * R
      VOLUME = (4.0/3.0) * PI * R**3
C     OUTPUT
      WRITE(*,*) 'CIRCUMFERENCE:', CIRCUM
      WRITE(*,*) 'VOLUME:       ', VOLUME
      STOP
      END
\end{verbatim}
\textbf{Important:}
\begin{itemize}
    \item PARAMETER for constant PI
    \item Use parentheses for fractional coefficients
    \item R**3 calculates radius cubed
\end{itemize}

\subsection*{Problem 9: Character Manipulation}
\begin{verbatim}
C     PROBLEM 9 SOLUTION
      PROGRAM CHAR_CONVERT
      CHARACTER C
      INTEGER ASCII, CODE
C     CHARACTER TO ASCII
      WRITE(*,*) 'ENTER A CHARACTER:'
      READ(*,*) C
      ASCII = ICHAR(C)
      WRITE(*,*) 'ASCII CODE:', ASCII
C     ASCII TO CHARACTER
      WRITE(*,*) 'ENTER ASCII CODE (65-90):'
      READ(*,*) CODE
      C = CHAR(CODE)
      WRITE(*,*) 'CHARACTER:', C
      STOP
      END
\end{verbatim}
\textbf{Notes:}
\begin{itemize}
    \item ICHAR returns ASCII value
    \item CHAR converts ASCII code to character
    \item Limited to single characters per input
\end{itemize}

\subsection*{Problem 10: Precision Demonstration}
\begin{verbatim}
C     PROBLEM 10 SOLUTION
      PROGRAM PRECISION
      REAL R
      DOUBLE PRECISION D
C     CALCULATIONS
      R = 1.0/3.0
      D = 1.0D0/3.0D0
C     OUTPUT
      WRITE(*,*) 'SINGLE PRECISION:', R
      WRITE(*,*) 'DOUBLE PRECISION:', D
      STOP
      END
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
SINGLE PRECISION:  0.3333333    
DOUBLE PRECISION:  0.3333333333333333
\end{verbatim}
\textbf{Explanation:}
\begin{itemize}
    \item REAL provides ~7 significant digits
    \item DOUBLE PRECISION provides ~15 digits
    \item Use D0 suffix for double-precision literals
\end{itemize}

\subsection*{Challenge Problem: Unit Converter}
\begin{verbatim}
C     CHALLENGE PROBLEM SOLUTION
      PROGRAM UNIT_CONV
      REAL KM, MILES
C     INPUT LOOP
10    WRITE(*,*) 'ENTER KILOMETERS (>=0):'
      READ(*,*) KM
      IF (KM .LT. 0.0) THEN
          WRITE(*,*) 'ERROR: NEGATIVE VALUE!'
          GOTO 10
      ENDIF
C     CONVERSION
      MILES = KM * 0.621371
C     OUTPUT
      WRITE(*,*) KM, 'KM =', MILES, 'MILES'
      STOP
      END
\end{verbatim}
\textbf{Features:}
\begin{itemize}
    \item Input validation with GOTO loop
    \item Real-to-real conversion maintains precision
    \item Clear error messaging
    \item Conversion factor from exact definition
\end{itemize}

\chapter{Conditional Statement in FORTRAN77}

\subsection*{Types of Conditional Statements}
Fortran 77 provides three main conditional constructs:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Type} & \textbf{Description} \\ 
\hline
Logical IF & Single-line conditional execution \\
Block IF & Multi-line IF-THEN-ENDIF structure \\
ELSE IF & Multiple alternative conditions \\
Nested IF & IF statements within other IF blocks \\
Arithmetic IF & Three-way branching (legacy) \\
\hline
\end{tabular}
\end{center}

\subsection*{Relational Operators}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Operator} & \textbf{Meaning} & \textbf{Example} \\ 
\hline
\texttt{.EQ.} & Equal to & \texttt{A .EQ. B} \\
\texttt{.NE.} & Not equal to & \texttt{X .NE. Y} \\
\texttt{.GT.} & Greater than & \texttt{N .GT. 0} \\
\texttt{.GE.} & Greater than or equal & \texttt{AGE .GE. 18} \\
\texttt{.LT.} & Less than & \texttt{TEMP .LT. 32.0} \\
\texttt{.LE.} & Less than or equal & \texttt{COUNT .LE. 10} \\
\hline
\end{tabular}
\end{center}

\subsection*{1. Logical IF (Single-Line)}
Executes one statement if condition is true:
\begin{verbatim}
C     PROGRAM: SINGLE_LINE_IF
C     CHECKS IF NUMBER IS POSITIVE
      PROGRAM LOGIF
      REAL NUM
      WRITE(*,*) 'ENTER A NUMBER:'
      READ(*,*) NUM
      IF (NUM .GT. 0.0) WRITE(*,*) 'POSITIVE NUMBER'
      STOP
      END
\end{verbatim}

\subsection*{2. Block IF Structure}
Executes multiple statements when condition is true:
\begin{verbatim}
C     PROGRAM: TEMPERATURE_CHECK
C     DEMONSTRATES BLOCK IF
      PROGRAM BLKIF
      REAL TEMP
      WRITE(*,*) 'ENTER TEMPERATURE (Â°C):'
      READ(*,*) TEMP
      
      IF (TEMP .LT. 0.0) THEN
          WRITE(*,*) 'WARNING: BELOW FREEZING!'
          WRITE(*,*) 'TAKE WINTER PRECAUTIONS'
      ENDIF
      
      STOP
      END
\end{verbatim}

\subsection*{3. IF-ELSE Structure}
Handles alternative conditions:
\begin{verbatim}
C     PROGRAM: GRADE_EVALUATOR
C     DEMONSTRATES IF-ELSE
      PROGRAM IFELSE
      INTEGER SCORE
      WRITE(*,*) 'ENTER TEST SCORE (0-100):'
      READ(*,*) SCORE
      
      IF (SCORE .GE. 60) THEN
          WRITE(*,*) 'PASSING GRADE'
      ELSE
          WRITE(*,*) 'FAILING GRADE'
      ENDIF
      
      STOP
      END
\end{verbatim}

\subsection*{4. ELSE IF Ladder}
Handles multiple conditions:
\begin{verbatim}
C     PROGRAM: TAX_BRACKET
C     DEMONSTRATES ELSE IF
      PROGRAM TAXCALC
      REAL INCOME
      WRITE(*,*) 'ENTER ANNUAL INCOME:'
      READ(*,*) INCOME
      
      IF (INCOME .LE. 50000.0) THEN
          WRITE(*,*) 'TAX BRACKET: 10%'
      ELSE IF (INCOME .LE. 100000.0) THEN
          WRITE(*,*) 'TAX BRACKET: 20%'
      ELSE IF (INCOME .LE. 250000.0) THEN
          WRITE(*,*) 'TAX BRACKET: 30%'
      ELSE
          WRITE(*,*) 'TAX BRACKET: 40%'
      ENDIF
      
      STOP
      END
\end{verbatim}

\subsection*{5. Nested IF Statements}
IF blocks within other IF blocks:
\begin{verbatim}
C     PROGRAM: LOGIN_SYSTEM
C     DEMONSTRATES NESTED IF
      PROGRAM LOGIN
      CHARACTER*10 USER
      INTEGER PASS
      LOGICAL ADMIN
      
      WRITE(*,*) 'ENTER USERNAME:'
      READ(*,*) USER
      WRITE(*,*) 'ENTER PASSWORD:'
      READ(*,*) PASS
      
      IF (USER .EQ. 'ADMIN') THEN
          IF (PASS .EQ. 12345) THEN
              ADMIN = .TRUE.
              WRITE(*,*) 'ADMIN ACCESS GRANTED'
          ELSE
              WRITE(*,*) 'INCORRECT PASSWORD'
          ENDIF
      ELSE
          WRITE(*,*) 'GUEST ACCESS ONLY'
      ENDIF
      
      STOP
      END
\end{verbatim}

\subsection*{6. Arithmetic IF (Legacy)}
Three-way branching based on expression sign:
\begin{verbatim}
C     PROGRAM: SIGN_CHECK
C     DEMONSTRATES ARITHMETIC IF (HISTORICAL)
      PROGRAM ARIF
      INTEGER NUM
      WRITE(*,*) 'ENTER AN INTEGER:'
      READ(*,*) NUM
      
      IF (NUM) 10, 20, 30
10    WRITE(*,*) 'NEGATIVE NUMBER'
      GOTO 40
20    WRITE(*,*) 'ZERO'
      GOTO 40
30    WRITE(*,*) 'POSITIVE NUMBER'
40    STOP
      END
\end{verbatim}

\subsection*{Compound Conditions}
Combine conditions with logical operators:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Operator} & \textbf{Meaning} \\ 
\hline
\texttt{.AND.} & Both conditions true \\
\texttt{.OR.} & Either condition true \\
\texttt{.NOT.} & Inverts condition \\
\hline
\end{tabular}
\end{center}

\begin{verbatim}
C     PROGRAM: WEATHER_CHECK
C     DEMONSTRATES COMPOUND CONDITIONS
      PROGRAM WEATHER
      REAL TEMP
      LOGICAL RAINING
      
      WRITE(*,*) 'ENTER TEMPERATURE (Â°C):'
      READ(*,*) TEMP
      WRITE(*,*) 'IS IT RAINING? (.TRUE./.FALSE.):'
      READ(*,*) RAINING
      
      IF (TEMP .GT. 25.0 .AND. .NOT. RAINING) THEN
          WRITE(*,*) 'GOOD DAY FOR BEACH'
      ELSE IF (TEMP .LT. 5.0 .OR. RAINING) THEN
          WRITE(*,*) 'STAY INDOORS'
      ELSE
          WRITE(*,*) 'NORMAL DAY'
      ENDIF
      
      STOP
      END
\end{verbatim}

\subsection*{Common Pitfalls}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Error} & \textbf{Solution} \\ 
\hline
Missing \texttt{ENDIF} & Always match IF with ENDIF \\
\hline
Using \texttt{=} instead of \texttt{.EQ.} & Fortran uses \texttt{.EQ.} for equality \\
\hline
No space around operators & \texttt{.LT.} not \texttt{.LT.} (depends on compiler) \\
\hline
Uninitialized variables & Always initialize variables before use \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
    \item Use indentation for nested conditionals
    \item Always include \texttt{ELSE} blocks for error handling
    \item Use parentheses for complex logical expressions
    \item Avoid arithmetic IF in new code
    \item Comment complex conditions
    \item Test boundary conditions thoroughly
\end{itemize}

\subsection*{Performance Tips}
\begin{itemize}
    \item Order conditions from most to least likely
    \item Use \texttt{ELSE IF} instead of multiple IFs when mutually exclusive
    \item Avoid deep nesting (max 3-4 levels)
    \item Use logical operators instead of nested IFs when possible
\end{itemize}

\section{Spacing in Nested Conditional Statements}

\subsection*{Fixed-Format Column Rules}
Fortran 77 requires strict column adherence for nested conditionals:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Columns} & \textbf{Purpose} \\ 
\hline
1-5 & Optional statement labels \\
6 & Continuation character (if needed) \\
7-72 & Executable code and conditions \\
73+ & Ignored (legacy punch card limit) \\
\hline
\end{tabular}
\end{center}

\subsection*{Indentation Guidelines}
\begin{itemize}
    \item \textbf{Base Level}: Start at column 7 for first IF
    \item \textbf{Nested Level}: Add 3 spaces per nesting level
    \item \textbf{Alignment}: Match THEN/ELSE/ENDIF with their IF level
    \item \textbf{Continuation}: Use column 6 for multi-line conditions
\end{itemize}

\subsection*{Properly Formatted Example}
\begin{verbatim}
C     PROGRAM: NESTED_GRADE_SYSTEM
      PROGRAM NESTED
      INTEGER SCORE
      CHARACTER*1 GRADE
      WRITE(*,*) 'ENTER EXAM SCORE (0-100):'
      READ(*,*) SCORE
      
C     Level 1 IF (column 7)
      IF (SCORE .GE. 90) THEN
C         Level 2 code (column 10)
          GRADE = 'A'
          IF (SCORE .EQ. 100) THEN       ! Level 2 IF (column 10)
C             Level 3 code (column 13)
              WRITE(*,*) 'PERFECT SCORE!'
          END IF                         ! Level 2 END IF
      ELSE IF (SCORE .GE. 80) THEN       ! Level 1 ELSE IF
          GRADE = 'B'
          IF (SCORE .GE. 85) THEN        ! Level 2 IF
              WRITE(*,*) 'NEARLY AN A!'
          END IF
      ELSE
          GRADE = 'F'
      END IF
      
      WRITE(*,*) 'YOUR GRADE: ', GRADE
      STOP
      END
\end{verbatim}

\subsection*{Column Breakdown}
\begin{verbatim}
Columns: 1   5 6 7   72
         |   | | |   |
         v   v v v   v
      IF (X .GT. 0) THEN        <- Level 1 (start at 7)
          IF (Y .LT. 10) THEN   <- Level 2 (+3 spaces)
              Z = X + Y         <- Level 3 (+6 spaces)
          END IF                <- Level 2 alignment
      END IF                    <- Level 1 alignment
\end{verbatim}

\subsection*{Common Spacing Errors}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Error} & \textbf{Solution} \\ 
\hline
Code starts in column 6 & Reserved for continuation markers \\
\hline
Uneven ELSE/END IF alignment & Use same indentation as opening IF \\
\hline
Overlapping columns (past 72) & Break lines with continuation marker \\
\hline
Mixed tabs and spaces & Use spaces only for consistency \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
    \item Use 3-space indentation per nesting level
    \item Align related keywords vertically:
    \begin{verbatim}
      IF (...) THEN
          ...
      ELSE IF (...) THEN
          ...
      ELSE
          ...
      END IF
    \end{verbatim}
    \item Limit nesting depth to 3-4 levels maximum
    \item Use comments to mark closing END IFs:
    \begin{verbatim}
      END IF  ! CLOSES TEMPERATURE CHECK
    \end{verbatim}
    \item Prefer this:
    \begin{verbatim}
      IF (A .GT. B) THEN
          ...
      END IF
    \end{verbatim}
    Over this:
    \begin{verbatim}
      IF(A.GT.B)THEN
      ...
      ENDIF
    \end{verbatim}
\end{itemize}

\subsection*{Multi-Line Condition Example}
\begin{verbatim}
C     PROGRAM: COMPLEX_CONDITION
      PROGRAM COMPLEX
      REAL X, Y
      LOGICAL FLAG
      WRITE(*,*) 'ENTER X, Y:'
      READ(*,*) X, Y
      
C     Continuation marker (* in column 6)
      IF (X .GT. 100.0 .AND.
     *    Y .LT. 50.0 .OR.
     *    FLAG) THEN
          WRITE(*,*) 'CONDITION MET'
      END IF
      
      STOP
      END
\end{verbatim}

\subsection*{Historical Context}
The strict column rules originate from:
\begin{itemize}
    \item 80-column punch card limitations
    \item Physical card layout requirements
    \item Early compiler design constraints
\end{itemize}

\subsection*{Modern Editor Tips}
\begin{itemize}
    \item Set tab stops at 6, 9, 12, etc.
    \item Enable column guides at 6 and 72
    \item Use syntax highlighting for:
    \begin{itemize}
        \item IF/THEN/ELSE keywords
        \item Continuation markers
        \item Comment lines
    \end{itemize}
    \item Configure auto-indent for nested blocks
\end{itemize}

\subsection*{Troubleshooting Table}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Compiler Error} & \textbf{Spacing Fix} \\ 
\hline
\texttt{Unclassifiable statement} & Check code starts in column 7+ \\
\hline
\texttt{Unterminated IF block} & Align END IF with opening IF \\
\hline
\texttt{Invalid character in column 6} & Remove unintended characters \\
\hline
\texttt{Label field ignored} & Move code from columns 1-5 to 7+ \\
\hline
\end{tabular}
\end{center}


\section{Conditional Statement Examples}

\subsection*{Example 1: Simple Logical IF}
\begin{verbatim}
C     CHECKS IF NUMBER IS POSITIVE
      PROGRAM POSCHK
      REAL NUM
      WRITE(*,*) 'ENTER A NUMBER:'
      READ(*,*) NUM
C     SINGLE-LINE CONDITIONAL
      IF (NUM .GT. 0.0) WRITE(*,*) 'POSITIVE NUMBER'
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Uses logical IF for single-condition check
- Executes WRITE only if NUM > 0
- No action for negative/zero values

\subsection*{Example 2: Block IF Structure}
\begin{verbatim}
C     TEMPERATURE STATUS CHECKER
      PROGRAM TEMPSTAT
      REAL TEMP
      WRITE(*,*) 'ENTER TEMPERATURE (Â°C):'
      READ(*,*) TEMP
      
      IF (TEMP .LT. 0.0) THEN
          WRITE(*,*) 'FREEZING TEMPERATURE!'
      ELSE IF (TEMP .GT. 35.0) THEN
          WRITE(*,*) 'HEAT WARNING!'
      ELSE
          WRITE(*,*) 'NORMAL TEMPERATURE'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Uses IF-ELSE IF-ELSE structure
- Checks multiple temperature ranges
- Default case for normal temperatures

\subsection*{Example 3: Even/Odd Checker}
\begin{verbatim}
C     DETERMINES IF NUMBER IS EVEN OR ODD
      PROGRAM EVENODD
      INTEGER NUM
      WRITE(*,*) 'ENTER AN INTEGER:'
      READ(*,*) NUM
      
      IF (MOD(NUM,2) .EQ. 0) THEN
          WRITE(*,*) 'EVEN NUMBER'
      ELSE
          WRITE(*,*) 'ODD NUMBER'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Uses MOD intrinsic function
- Compares remainder with .EQ. operator
- Demonstrates simple IF-ELSE structure

\subsection*{Example 4: Grade Calculator}
\begin{verbatim}
C     CONVERTS SCORE TO LETTER GRADE
      PROGRAM GRADE
      INTEGER SCORE
      WRITE(*,*) 'ENTER EXAM SCORE (0-100):'
      READ(*,*) SCORE
      
      IF (SCORE .GE. 90) THEN
          WRITE(*,*) 'GRADE: A'
      ELSE IF (SCORE .GE. 80) THEN
          WRITE(*,*) 'GRADE: B'
      ELSE IF (SCORE .GE. 70) THEN
          WRITE(*,*) 'GRADE: C'
      ELSE IF (SCORE .GE. 60) THEN
          WRITE(*,*) 'GRADE: D'
      ELSE
          WRITE(*,*) 'GRADE: F'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Notes:}
- Sequential ELSE IF structure
- Conditions checked from highest to lowest
- No overlap between grade ranges

\subsection*{Example 5: Login System}
\begin{verbatim}
C     SIMPLE USER AUTHENTICATION
      PROGRAM LOGIN
      CHARACTER*10 USER
      INTEGER PASS
      WRITE(*,*) 'ENTER USERNAME:'
      READ(*,*) USER
      WRITE(*,*) 'ENTER PASSWORD:'
      READ(*,*) PASS
      
      IF (USER .EQ. 'ADMIN') THEN
          IF (PASS .EQ. 12345) THEN
              WRITE(*,*) 'ACCESS GRANTED'
          ELSE
              WRITE(*,*) 'WRONG PASSWORD'
          ENDIF
      ELSE
          WRITE(*,*) 'INVALID USER'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Nested IF statements
- Outer check for username
- Inner check for password
- Multiple ELSE conditions

\subsection*{Example 6: Voting Eligibility}
\begin{verbatim}
C     CHECKS VOTING ELIGIBILITY
      PROGRAM VOTE
      INTEGER AGE
      LOGICAL CITIZEN
      WRITE(*,*) 'ENTER AGE:'
      READ(*,*) AGE
      WRITE(*,*) 'CITIZEN? (.TRUE./.FALSE.):'
      READ(*,*) CITIZEN
      
      IF (AGE .GE. 18 .AND. CITIZEN) THEN
          WRITE(*,*) 'ELIGIBLE TO VOTE'
      ELSE
          WRITE(*,*) 'NOT ELIGIBLE'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Uses .AND. logical operator
- Combines multiple conditions
- Requires both conditions to be true

\subsection*{Example 7: Arithmetic IF (Legacy)}
\begin{verbatim}
C     NUMBER SIGN CHECK (HISTORICAL)
      PROGRAM ARIF
      INTEGER NUM
      WRITE(*,*) 'ENTER INTEGER:'
      READ(*,*) NUM
      
      IF (NUM) 10, 20, 30
10    WRITE(*,*) 'NEGATIVE'
      GOTO 40
20    WRITE(*,*) 'ZERO'
      GOTO 40
30    WRITE(*,*) 'POSITIVE'
40    STOP
      END
\end{verbatim}
\textbf{Notes:}
- Uses legacy arithmetic IF
- Branches based on negative/zero/positive
- Requires statement labels
- Not recommended for new code

\subsection*{Example 8: Division Validation}
\begin{verbatim}
C     SAFE DIVISION PROGRAM
      PROGRAM DIVIDE
      REAL A, B, RESULT
      WRITE(*,*) 'ENTER TWO NUMBERS:'
      READ(*,*) A, B
      
      IF (B .EQ. 0.0) THEN
          WRITE(*,*) 'ERROR: DIVISION BY ZERO'
      ELSE
          RESULT = A / B
          WRITE(*,*) 'RESULT:', RESULT
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Prevents division by zero
- Uses .EQ. for float comparison
- Error handling before operation

\subsection*{Example 9: Range Checker}
\begin{verbatim}
C     NUMBER RANGE VALIDATION
      PROGRAM RANGE
      INTEGER NUM
      WRITE(*,*) 'ENTER NUMBER (1-100):'
      READ(*,*) NUM
      
      IF (NUM .LT. 1) THEN
          WRITE(*,*) 'TOO SMALL'
      ELSE IF (NUM .GT. 100) THEN
          WRITE(*,*) 'TOO LARGE'
      ELSE
          WRITE(*,*) 'VALID NUMBER'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Validates input range
- Separate checks for lower/upper bounds
- Else case for valid numbers

\subsection*{Example 10: Simple Calculator}
\begin{verbatim}
C     MENU-DRIVEN CALCULATOR
      PROGRAM CALC
      REAL A, B
      INTEGER CHOICE
      WRITE(*,*) 'ENTER TWO NUMBERS:'
      READ(*,*) A, B
      WRITE(*,*) '1:ADD 2:SUB 3:MUL 4:DIV'
      READ(*,*) CHOICE
      
      IF (CHOICE .EQ. 1) THEN
          WRITE(*,*) 'SUM:', A+B
      ELSE IF (CHOICE .EQ. 2) THEN
          WRITE(*,*) 'DIFF:', A-B
      ELSE IF (CHOICE .EQ. 3) THEN
          WRITE(*,*) 'PRODUCT:', A*B
      ELSE IF (CHOICE .EQ. 4) THEN
          IF (B .NE. 0.0) THEN
              WRITE(*,*) 'QUOTIENT:', A/B
          ELSE
              WRITE(*,*) 'CANNOT DIVIDE BY ZERO'
          ENDIF
      ELSE
          WRITE(*,*) 'INVALID CHOICE'
      ENDIF
      
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Nested IF in division case
- Menu-driven interface
- Multiple conditional checks
- Error handling for invalid menu choices

\subsection*{General Notes}
\begin{itemize}
\item All examples use Fortran 77 fixed-format
\item Column 6+ for code, column 1 for comments
\item Use .EQ. instead of == for comparisons
\item ELSE IF must be on same line as ELSE
\item Indentation improves readability
\end{itemize}

\section{Exercises: Conditional Statements}

\subsection*{Problem 1: Basic If-Else}  
Write a program that:  
\begin{itemize}  
\item Reads an integer  
\item Prints "POSITIVE" if >0, "NEGATIVE" if <0, "ZERO" otherwise  
\end{itemize}

\subsection*{Problem 2: Grade Calculator}  
Create a program that:  
\begin{itemize}  
\item Takes a score (0-100) as input  
\item Uses ELSE IF to assign grades:  
  - A (90-100), B (80-89), C (70-79), D (60-69), F (<60)  
\end{itemize}

\subsection*{Problem 3: Voting Eligibility}  
Write a program that:  
\begin{itemize}  
\item Checks if a user can vote  
\item Input: Age and citizenship status (logical)  
\item Output eligibility using .AND. operator  
\end{itemize}

\subsection*{Problem 4: Login System}  
Create a program with:  
\begin{itemize}  
\item Nested IF statements  
\item Checks username (text) and password (number)  
\item Grants access only if both match predefined values  
\end{itemize}

\subsection*{Problem 5: Leap Year Checker}  
Write a program that:  
\begin{itemize}  
\item Determines if a year is a leap year  
\item Conditions: Divisible by 4 but not 100, unless also by 400  
\item Use compound logical operators  
\end{itemize}

\subsection*{Problem 6: Temperature Advisor}  
Create a program that:  
\begin{itemize}  
\item Reads temperature  
\item Advises:  
  - "HOT" (>35Â°C), "COLD" (<10Â°C), "MODERATE" otherwise  
\item Use ELSE IF structure  
\end{itemize}

\subsection*{Problem 7: Division Validator}  
Write a program that:  
\begin{itemize}  
\item Takes two numbers  
\item Divides them only if denominator is not equality 0
\item Prints error message for zero denominator  
\end{itemize}

\subsection*{Problem 8: Vowel Checker}  
Create a program that:  
\begin{itemize}  
\item Reads a single character  
\item Uses nested IF to check if it's a vowel (A/E/I/O/U)  
\item Case insensitive (.EQ. with uppercase and lowercase)  
\end{itemize}

\subsection*{Problem 9: Simple Calculator}  
Write a menu-driven program that:  
\begin{itemize}  
\item Takes two numbers and operation choice (1-4)  
\item Performs +, -, *, / based on user selection  
\item Handles invalid menu choices  
\end{itemize}

\subsection*{Problem 10: Number Range Check}  
Create a program that:  
\begin{itemize}  
\item Checks if number is between 1-100  
\item Prints "VALID" or "INVALID"  
\item Adds specific messages for "TOO LOW" (<1) and "TOO HIGH" (>100)  
\end{itemize}

\subsection*{Challenge Problem: ATM Simulator}  
Write a program that:  
\begin{itemize}  
\item Checks PIN (4-digit number)  
\item Checks account balance before withdrawal  
\item Outputs:  
  - "INVALID PIN" if wrong  
  - "INSUFFICIENT FUNDS" if balance < requested amount  
  - "SUCCESS" otherwise  
\end{itemize}

\section{Exercise Answers: Conditional Statements}

\subsection*{Problem 1: Basic If-Else}
\begin{verbatim}
C     DETERMINES NUMBER SIGN
      PROGRAM POSNEG
      INTEGER NUM
      WRITE(*,*) 'ENTER AN INTEGER:'
      READ(*,*) NUM
      
      IF (NUM .GT. 0) THEN
          WRITE(*,*) 'POSITIVE'
      ELSE IF (NUM .LT. 0) THEN
          WRITE(*,*) 'NEGATIVE'
      ELSE
          WRITE(*,*) 'ZERO'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Uses IF-ELSE IF-ELSE structure
- Checks >0 first, then <0, default to zero
- .GT. and .LT. relational operators

\subsection*{Problem 2: Grade Calculator}
\begin{verbatim}
C     ASSIGNS LETTER GRADES
      PROGRAM GRADE
      INTEGER SCORE
      WRITE(*,*) 'ENTER SCORE (0-100):'
      READ(*,*) SCORE
      
      IF (SCORE .GE. 90) THEN
          WRITE(*,*) 'GRADE: A'
      ELSE IF (SCORE .GE. 80) THEN
          WRITE(*,*) 'GRADE: B'
      ELSE IF (SCORE .GE. 70) THEN
          WRITE(*,*) 'GRADE: C'
      ELSE IF (SCORE .GE. 60) THEN
          WRITE(*,*) 'GRADE: D'
      ELSE
          WRITE(*,*) 'GRADE: F'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- ELSE IF ladder structure
- Descending order of conditions
- Inclusive lower bounds

\subsection*{Problem 3: Voting Eligibility}
\begin{verbatim}
C     CHECKS VOTING RIGHTS
      PROGRAM VOTE
      INTEGER AGE
      LOGICAL CITIZEN
      WRITE(*,*) 'ENTER AGE:'
      READ(*,*) AGE
      WRITE(*,*) 'CITIZEN? (.TRUE./.FALSE.):'
      READ(*,*) CITIZEN
      
      IF (AGE .GE. 18 .AND. CITIZEN) THEN
          WRITE(*,*) 'ELIGIBLE TO VOTE'
      ELSE
          WRITE(*,*) 'NOT ELIGIBLE'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Uses .AND. logical operator
- Combines numeric and logical input
- Single condition check

\subsection*{Problem 4: Login System}
\begin{verbatim}
C     SIMPLE AUTHENTICATION
      PROGRAM LOGIN
      CHARACTER*10 USER
      INTEGER PASS
      WRITE(*,*) 'ENTER USERNAME:'
      READ(*,*) USER
      WRITE(*,*) 'ENTER PASSWORD:'
      READ(*,*) PASS
      
      IF (USER .EQ. 'ADMIN') THEN
          IF (PASS .EQ. 1234) THEN
              WRITE(*,*) 'ACCESS GRANTED'
          ELSE
              WRITE(*,*) 'WRONG PASSWORD'
          END IF
      ELSE
          WRITE(*,*) 'INVALID USER'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Nested IF structure
- Outer check for username
- Inner check for password
- Character comparison with .EQ.

\subsection*{Problem 5: Leap Year Checker}
\begin{verbatim}
C     DETERMINES LEAP YEARS
      PROGRAM LEAP
      INTEGER YEAR
      LOGICAL COND1, COND2, COND3
      WRITE(*,*) 'ENTER YEAR:'
      READ(*,*) YEAR
      
      COND1 = MOD(YEAR,4) .EQ. 0
      COND2 = MOD(YEAR,100) .NE. 0
      COND3 = MOD(YEAR,400) .EQ. 0
      
      IF ((COND1 .AND. COND2) .OR. COND3) THEN
          WRITE(*,*) 'LEAP YEAR'
      ELSE
          WRITE(*,*) 'NOT A LEAP YEAR'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Logic:}
- Uses MOD for divisibility checks
- Combines conditions with .AND./.OR.
- Follows Gregorian calendar rules

\subsection*{Problem 6: Temperature Advisor}
\begin{verbatim}
C     WEATHER ADVISORY SYSTEM
      PROGRAM TEMPADV
      REAL TEMP
      WRITE(*,*) 'ENTER TEMPERATURE (Â°C):'
      READ(*,*) TEMP
      
      IF (TEMP .GT. 35.0) THEN
          WRITE(*,*) 'HOT'
      ELSE IF (TEMP .LT. 10.0) THEN
          WRITE(*,*) 'COLD'
      ELSE
          WRITE(*,*) 'MODERATE'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Structure:}
- Three-way ELSE IF
- Floating point comparisons
- Explicit temperature thresholds

\subsection*{Problem 7: Division Validator}
\begin{verbatim}
C     SAFE DIVISION PROGRAM
      PROGRAM DIVIDE
      REAL A, B
      WRITE(*,*) 'ENTER TWO NUMBERS:'
      READ(*,*) A, B
      
      IF (B .EQ. 0.0) THEN
          WRITE(*,*) 'ERROR: DIVISION BY ZERO'
      ELSE
          WRITE(*,*) 'RESULT:', A/B
      END IF
      STOP
      END
\end{verbatim}
\textbf{Safety:}
- Checks denominator before division
- Uses .EQ. for float comparison
- Prevents runtime errors

\subsection*{Problem 8: Vowel Checker}
\begin{verbatim}
C     VOWEL IDENTIFICATION
      PROGRAM VOWEL
      CHARACTER C
      WRITE(*,*) 'ENTER A LETTER:'
      READ(*,*) C
      
      IF (C .EQ. 'A' .OR. C .EQ. 'E' .OR. 
     *    C .EQ. 'I' .OR. C .EQ. 'O' .OR.
     *    C .EQ. 'U' .OR. C .EQ. 'a' .OR.
     *    C .EQ. 'e' .OR. C .EQ. 'i' .OR.
     *    C .EQ. 'o' .OR. C .EQ. 'u') THEN
          WRITE(*,*) 'VOWEL'
      ELSE
          WRITE(*,*) 'NOT A VOWEL'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Multi-line condition with continuation (* in column 6)
- Checks both uppercase and lowercase
- Uses .OR. for multiple possibilities

\subsection*{Problem 9: Simple Calculator}
\begin{verbatim}
C     MENU-DRIVEN CALCULATOR
      PROGRAM CALC
      REAL A, B
      INTEGER CHOICE
      WRITE(*,*) 'ENTER TWO NUMBERS:'
      READ(*,*) A, B
      WRITE(*,*) '1:ADD 2:SUB 3:MUL 4:DIV'
      READ(*,*) CHOICE
      
      IF (CHOICE .EQ. 1) THEN
          WRITE(*,*) 'SUM:', A+B
      ELSE IF (CHOICE .EQ. 2) THEN
          WRITE(*,*) 'DIFFERENCE:', A-B
      ELSE IF (CHOICE .EQ. 3) THEN
          WRITE(*,*) 'PRODUCT:', A*B
      ELSE IF (CHOICE .EQ. 4) THEN
          IF (B .NE. 0.0) THEN
              WRITE(*,*) 'QUOTIENT:', A/B
          ELSE
              WRITE(*,*) 'DIVISION BY ZERO!'
          END IF
      ELSE
          WRITE(*,*) 'INVALID CHOICE'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Structure:}
- Nested IF for division check
- ELSE IF ladder for menu options
- ELSE clause for invalid input

\subsection*{Problem 10: Number Range Check}
\begin{verbatim}
C     RANGE VALIDATION
      PROGRAM RANGE
      INTEGER NUM
      WRITE(*,*) 'ENTER NUMBER (1-100):'
      READ(*,*) NUM
      
      IF (NUM .LT. 1) THEN
          WRITE(*,*) 'TOO LOW'
      ELSE IF (NUM .GT. 100) THEN
          WRITE(*,*) 'TOO HIGH'
      ELSE
          WRITE(*,*) 'VALID'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Logic:}
- Checks lower bound first
- Then upper bound
- Else validates number

\subsection*{Challenge Problem: ATM Simulator}
\begin{verbatim}
C     ATM TRANSACTION SYSTEM
      PROGRAM ATM
      INTEGER PIN, CORRECT_PIN
      REAL BALANCE, AMOUNT
      PARAMETER (CORRECT_PIN = 5678)
      BALANCE = 2500.0
      
      WRITE(*,*) 'ENTER PIN:'
      READ(*,*) PIN
      WRITE(*,*) 'ENTER WITHDRAWAL AMOUNT:'
      READ(*,*) AMOUNT
      
      IF (PIN .NE. CORRECT_PIN) THEN
          WRITE(*,*) 'INVALID PIN'
      ELSE IF (AMOUNT .GT. BALANCE) THEN
          WRITE(*,*) 'INSUFFICIENT FUNDS'
      ELSE
          WRITE(*,*) 'SUCCESS'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Security:}
- PIN validation first
- Balance check second
- PARAMETER for secure PIN storage

\chapter{LOOPS \& LOOPS IN FORTRAN77}

\section{Loops in Fortran 77}

\subsection*{Types of Loops}
Fortran 77 provides three main looping constructs:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Type} & \textbf{Description} \\ 
\hline
DO Loop & Fixed iteration count \\
DO-WHILE & Conditional looping \\
Arithmetic IF (legacy) & GOTO-based iteration \\
\hline
\end{tabular}
\end{center}

\subsection*{1. DO Loop (Fixed Iterations)}
\begin{verbatim}
C     SIMPLE DO LOOP EXAMPLE
      PROGRAM DO_LOOP
      INTEGER I
C     LOOP FROM 1 TO 5 (STEP 1)
      DO 10 I = 1, 5
          WRITE(*,*) 'ITERATION:', I
10    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Key Features:}
\begin{itemize}
\item \texttt{DO 10 I = 1, 5} - Label 10 marks loop end
\item \texttt{CONTINUE} - Loop termination marker
\item Default step size = 1
\item Loop variable (I) automatically increments
\end{itemize}

\subsection*{DO Loop with Step}
\begin{verbatim}
C     LOOP WITH STEP VALUE
      PROGRAM DO_STEP
      INTEGER N
C     COUNTDOWN FROM 10 TO 0, STEP -2
      DO 20 N = 10, 0, -2
          WRITE(*,*) 'COUNT:', N
20    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Step value (-2) specified after range
- Loop variable decreases by 2 each iteration
- Loop ends when N < 0

\subsection*{2. DO-WHILE Loop (Conditional)}
\begin{verbatim}
C     CONDITIONAL LOOP EXAMPLE
      PROGRAM DOWHILE
      REAL TEMP
      TEMP = 100.0
C     LOOP WHILE TEMPERATURE > 32.0
30    IF (TEMP .GT. 32.0) THEN
          WRITE(*,*) 'CURRENT TEMP:', TEMP
          TEMP = TEMP - 10.0
          GOTO 30
      END IF
      STOP
      END
\end{verbatim}
\textbf{Structure:}
- Label 30 marks loop start
- Condition checked before each iteration
- GOTO creates loopback
- Variable modification inside loop

\subsection*{3. Nested DO Loops}
\begin{verbatim}
C     MULTIPLICATION TABLE GENERATOR
      PROGRAM NESTED
      INTEGER I, J
C     OUTER LOOP (ROWS)
      DO 40 I = 1, 5
C         INNER LOOP (COLUMNS)
          DO 50 J = 1, 5
              WRITE(*,*) I, 'X', J, '=', I*J
50        CONTINUE
40    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Outer loop (I) controls rows
- Inner loop (J) controls columns
- Unique labels for each loop (40, 50)
- Proper indentation for readability

\subsection*{4. Loop Control Statements}
Fortran 77 has limited control flow:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Statement} & \textbf{Purpose} \\ 
\hline
\texttt{GOTO} & Jump to label \\
\texttt{EXIT} & Terminate loop (non-standard) \\
\texttt{CYCLE} & Skip iteration (non-standard) \\
\hline
\end{tabular}
\end{center}

\begin{verbatim}
C     LOOP EXIT EXAMPLE
      PROGRAM LOOPEXIT
      INTEGER COUNT
      COUNT = 1
60    IF (COUNT .LE. 10) THEN
          IF (COUNT .EQ. 5) GOTO 70
          WRITE(*,*) COUNT
          COUNT = COUNT + 1
          GOTO 60
      END IF
70    STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Exits loop when COUNT reaches 5
- Uses GOTO to jump out of loop
- Limited to label-based control

\subsection*{5. Legacy Arithmetic IF Loop}
\begin{verbatim}
C     HISTORICAL APPROACH (NOT RECOMMENDED)
      PROGRAM ARIF
      INTEGER N
      N = 5
80    WRITE(*,*) N
      N = N - 1
      IF (N) 90, 90, 80
90    STOP
      END
\end{verbatim}
\textbf{Behavior:}
- IF (N) 90, 90, 80 branches to:
  - 90 if N < 0
  - 90 if N = 0
  - 80 if N > 0
- Creates countdown from 5 to 0

\subsection*{Loop Variable Rules}
\begin{itemize}
\item Loop variable must be INTEGER
\item Modification inside loop is allowed but discouraged
\item Value persists after loop exit
\item Zero-trip loops possible:
\begin{verbatim}
DO 100 I = 5, 1  ! Never executes
\end{verbatim}
\end{itemize}

\subsection*{Common Loop Patterns}

\subsubsection*{Summation}
\begin{verbatim}
C     SUM FIRST 10 NATURAL NUMBERS
      PROGRAM SUMMATION
      INTEGER I, SUM
      SUM = 0
      DO 110 I = 1, 10
          SUM = SUM + I
110   CONTINUE
      WRITE(*,*) 'TOTAL:', SUM
      STOP
      END
\end{verbatim}

\subsubsection*{Input Validation}
\begin{verbatim}
C     REPEAT UNTIL VALID INPUT
      PROGRAM VALIDATE
      REAL X
120   WRITE(*,*) 'ENTER POSITIVE NUMBER:'
      READ(*,*) X
      IF (X .LE. 0.0) GOTO 120
      WRITE(*,*) 'THANK YOU'
      STOP
      END
\end{verbatim}

\subsection*{Best Practices}
\begin{itemize}
\item Use DO loops for known iterations
\item Prefer DO-WHILE for condition-based loops
\item Avoid modifying loop variables
\item Use unique labels for nested loops
\item Indent loop bodies consistently
\item Comment complex loop logic
\end{itemize}

\subsection*{Common Errors}
\begin{center}
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Error} & \textbf{Solution} \\ 
\hline
Missing CONTINUE & Ensure every DO has matching label \\
\hline
Infinite loop & Verify exit condition changes \\
\hline
Label mismatch & Check GOTO targets \\
\hline
Real loop variables & Use INTEGER for counters \\
\hline
\end{tabular}
\end{center}

\subsection*{Performance Considerations}
\begin{itemize}
\item Place loop-invariant code outside
\item Minimize I/O inside loops
\item Avoid complex conditions in DO-WHILE
\item Use INTEGER for counters
\item Prefer DO loops over GOTO when possible
\end{itemize}

\section{Loop Examples in Fortran 77}

\subsection*{1. DO Loops (Fixed Iterations)}
\subsubsection*{Example 1: Basic Number Sequence}
\begin{verbatim}
C     PRINT NUMBERS 1 TO 5
      PROGRAM DO1
      INTEGER I
C     START LOOP AT 1, END AT 5, STEP 1
      DO 10 I = 1, 5
          WRITE(*,*) 'NUMBER:', I
10    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Loop variable I starts at 1, increments by 1
- Executes exactly 5 times
- CONTINUE marks loop end (label 10)

\subsubsection*{Example 2: Step Value in Reverse}
\begin{verbatim}
C     COUNTDOWN FROM 10 TO 0
      PROGRAM DO2
      INTEGER COUNT
C     STEP BY -2 (DECREMENT)
      DO 20 COUNT = 10, 0, -2
          WRITE(*,*) 'COUNTDOWN:', COUNT
20    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Negative step value (-2)
- Loop ends when COUNT < 0
- Output: 10, 8, 6, 4, 2, 0

\subsubsection*{Example 3: Nested Multiplication Table}
\begin{verbatim}
C     5x5 MULTIPLICATION TABLE
      PROGRAM DO3
      INTEGER I, J
C     OUTER LOOP FOR ROWS
      DO 30 I = 1, 5
C         INNER LOOP FOR COLUMNS
          DO 40 J = 1, 5
              WRITE(*,*) I, 'x', J, '=', I*J
40        CONTINUE
30    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Outer loop (I) runs 5 times
- Inner loop (J) completes fully for each I
- Unique labels (30, 40) for each loop

\subsection*{2. DO-WHILE Loops (Conditional)}
\subsubsection*{Example 1: Temperature Monitor}
\begin{verbatim}
C     COOLING SIMULATION
      PROGRAM WHILE1
      REAL TEMP
      TEMP = 100.0
50    IF (TEMP .GT. 32.0) THEN
          WRITE(*,*) 'Current Temp:', TEMP
          TEMP = TEMP - 10.0
          GOTO 50
      END IF
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Loop continues while TEMP > 32.0
- GOTO 50 creates loopback
- TEMP decreases by 10 each iteration

\subsubsection*{Example 2: Sum Until Threshold}
\begin{verbatim}
C     SUM NUMBERS UNTIL TOTAL > 100
      PROGRAM WHILE2
      INTEGER NUM, TOTAL
      TOTAL = 0
60    IF (TOTAL .LE. 100) THEN
          WRITE(*,*) 'Enter number:'
          READ(*,*) NUM
          TOTAL = TOTAL + NUM
          GOTO 60
      END IF
      WRITE(*,*) 'Final total:', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Loop until TOTAL exceeds 100
- User input inside loop
- Condition checked before each iteration

\subsubsection*{Example 3: Input Validation}
\begin{verbatim}
C     VALIDATE POSITIVE INPUT
      PROGRAM WHILE3
      REAL X
70    WRITE(*,*) 'Enter positive value:'
      READ(*,*) X
      IF (X .LE. 0.0) THEN
          WRITE(*,*) 'Invalid! Try again'
          GOTO 70
      END IF
      WRITE(*,*) 'Accepted:', X
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Forces valid input using GOTO
- Loop continues until X > 0
- No separate loop variable needed

\subsection*{3. Arithmetic IF Loops (Legacy)}
\subsubsection*{Example 1: Simple Countdown}
\begin{verbatim}
C     COUNTDOWN USING ARITHMETIC IF
      PROGRAM ARIF1
      INTEGER N
      N = 5
80    WRITE(*,*) N
      N = N - 1
C     IF(N) neg,zero,pos labels
      IF (N) 90, 90, 80
90    STOP
      END
\end{verbatim}
\textbf{Explanation:}
- IF (N) branches to 90 if N â‰¤ 0
- Branches to 80 if N > 0
- Output: 5 4 3 2 1 0

\subsubsection*{Example 2: Sum Positive Numbers}
\begin{verbatim}
C     SUM INPUT UNTIL NEGATIVE
      PROGRAM ARIF2
      INTEGER NUM, SUM
      SUM = 0
100   WRITE(*,*) 'Enter number (negative to stop):'
      READ(*,*) NUM
C     BRANCH BASED ON NUM SIGN
      IF (NUM) 110, 120, 120
110   WRITE(*,*) 'Total:', SUM
      STOP
120   SUM = SUM + NUM
      GOTO 100
      END
\end{verbatim}
\textbf{Features:}
- 110: Negative number exit
- 120: Zero/positive accumulation
- Three-way branching

\subsubsection*{Example 3: Password Attempts}
\begin{verbatim}
C     LIMITED PASSWORD ATTEMPTS
      PROGRAM ARIF3
      INTEGER TRIES, PASS
      TRIES = 3
      PASS = 1234
130   WRITE(*,*) 'Enter password (', TRIES, 'left):'
      READ(*,*) INPUT
      IF (INPUT .NE. PASS) THEN
          TRIES = TRIES - 1
          IF (TRIES) 140, 140, 130
      ELSE
          WRITE(*,*) 'Access granted'
          STOP
      END IF
140   WRITE(*,*) 'Account locked'
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Gives 3 password attempts
- Uses Arithmetic IF for attempt counting
- Combines modern IF-THEN with legacy branching

\section{Spacing for Loops and Nested Loops}

\subsection*{Fixed-Format Column Rules}
Fortran 77 requires strict adherence to column-based formatting:
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Columns} & \textbf{Purpose} \\ 
\hline
1-5 & Statement labels (optional) \\
6 & Continuation character \\
7-72 & Executable code \\
73-80 & Ignored (historical) \\
\hline
\end{tabular}
\end{center}

\subsection*{Basic Loop Structure}
\begin{verbatim}
C     BASIC DO LOOP
      PROGRAM LOOP1
      INTEGER I
C     DO statement starts at column 7
      DO 10 I = 1, 5
          WRITE(*,*) I  ! Body indented 3 spaces
10    CONTINUE          ! Label 10 in columns 1-5
      STOP
      END
\end{verbatim}

\subsection*{Nested Loop Spacing}
\begin{verbatim}
C     NESTED LOOPS
      PROGRAM NESTED
      INTEGER I, J
C     Outer loop
      DO 20 I = 1, 3
C         Inner loop (indented 3 spaces)
          DO 30 J = 1, 2
              WRITE(*,*) I, J  ! Double indentation
30        CONTINUE             ! Inner label
20    CONTINUE                 ! Outer label
      STOP
      END
\end{verbatim}

\subsection*{Key Spacing Rules}
\begin{itemize}
\item \textbf{DO Statement}: Start at column 7
\item \textbf{Labels}: Place in columns 1-5
\item \textbf{Body}: Indent 3-6 spaces per nesting level
\item \textbf{CONTINUE}: Align with corresponding DO
\end{itemize}

\subsection*{Proper Column Layout}
\begin{verbatim}
Columns: 1   5 6 7   72
         |   | | |   |
         v   v v v   v
      DO 40 I = 1, 3     <- Outer loop (col 7)
          DO 50 J = 1, 2 <- Inner loop (+3 spaces)
              ...        <- Body (+6 spaces)
50        CONTINUE       <- Inner label (col 1-5)
40    CONTINUE           <- Outer label
\end{verbatim}

\subsection*{Common Mistakes}
\begin{center}
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Error} & \textbf{Solution} \\ 
\hline
Code starts in column 6 & Shift to column 7+ \\
\hline
Missing CONTINUE label & Ensure every DO has matching label \\
\hline
Overlapping labels & Use unique numbers (10, 20, 30, etc.) \\
\hline
Body not indented & Add 3-6 spaces per nesting level \\
\hline
\end{tabular}
\end{center}

\subsection*{Best Practices}
\begin{itemize}
\item \textbf{Indentation}: Use 3 spaces per nesting level
\item \textbf{Labels}: Increment by 10s (10, 20, 30) for flexibility
\item \textbf{Comments}: Describe loop purpose
\item \textbf{Deep Nesting}: Avoid beyond 3 levels
\item \textbf{Variable Names}: Use meaningful names (ROW/COL vs I/J)
\end{itemize}

\subsection*{Advanced Example: Triple Nested Loop}
\begin{verbatim}
C     3D MATRIX INITIALIZATION
      PROGRAM TRIPLE
      INTEGER X, Y, Z
C     Outer loop
      DO 100 X = 1, 2
C         Middle loop
          DO 200 Y = 1, 3
C             Inner loop
              DO 300 Z = 1, 2
                  WRITE(*,*) X, Y, Z
300           CONTINUE
200       CONTINUE
100   CONTINUE
      STOP
      END
\end{verbatim}

\subsection*{Legacy Approach (Arithmetic IF)}
\begin{verbatim}
C     NOT RECOMMENDED - HISTORICAL USE
      PROGRAM LEGACY
      INTEGER K
      K = 1
400   WRITE(*,*) K
      K = K + 1
      IF (K - 5) 400, 400, 500
500   STOP
      END
\end{verbatim}

\subsection*{Performance Tips}
\begin{itemize}
\item Place WRITE/READ outside loops when possible
\item Prefer DO loops over GOTO for readability
\item Initialize variables before loops
\item Avoid modifying loop counters
\end{itemize}
\section{Exercises: Loops in Fortran 77}

\subsection*{Problem 1: Basic DO Loop}  
Write a program that:  
\begin{itemize}  
\item Uses a DO loop to print numbers 1 through 10  
\item Follows fixed-format column rules  
\item Uses a CONTINUE statement  
\end{itemize}

\subsection*{Problem 2: Step Value Practice}  
Create a program that:  
\begin{itemize}  
\item Prints even numbers between 2 and 20  
\item Uses a DO loop with step value 2  
\item Labels loop termination properly  
\end{itemize}

\subsection*{Problem 3: Nested Loop Grid}  
Write a program that:  
\begin{itemize}  
\item Uses nested DO loops to print all (i,j) pairs for a 3x3 grid  
\item Outer loop for i-values (1-3)  
\item Inner loop for j-values (1-3)  
\end{itemize}

\subsection*{Problem 4: Conditional Summation}  
Create a program that:  
\begin{itemize}  
\item Uses a DO-WHILE structure (IF-GOTO)  
\item Accumulates numbers until total exceeds 100  
\item Shows intermediate sums  
\end{itemize}

\subsection*{Problem 5: Input Validation}  
Write a program that:  
\begin{itemize}  
\item Repeatedly asks for positive number input  
\item Uses a DO-WHILE loop with .LE. operator  
\item Exits only when valid input received  
\end{itemize}

\subsection*{Problem 6: Pattern Printing}  
Create a program that:  
\begin{itemize}  
\item Uses nested loops to print:  
\begin{verbatim}
*
**
***
\end{verbatim}  
\item Each level adds one more asterisk  
\end{itemize}

\subsection*{Problem 7: Factorial Calculator}  
Write a program that:  
\begin{itemize}  
\item Calculates factorial of user-input number  
\item Uses a DO loop for multiplication  
\item Handles 0! = 1 case  
\end{itemize}

\subsection*{Problem 8: Early Exit Loop}  
Create a program that:  
\begin{itemize}  
\item Reads numbers until negative entered  
\item Uses GOTO to exit loop early  
\item Accumulates positive numbers  
\end{itemize}

\subsection*{Problem 9: Legacy Countdown}  
Write a program that:  
\begin{itemize}  
\item Uses arithmetic IF loop structure  
\item Counts down from 5 to 1  
\item Prints "LIFTOFF!" at end  
\end{itemize}

\subsection*{Problem 10: Login System}  
Create a program that:  
\begin{itemize}  
\item Gives 3 password attempts  
\item Uses loop with attempt counter  
\item Shows remaining attempts  
\item Uses fixed-format spacing  
\end{itemize}

\subsection*{Challenge Problem: Prime Checker}  
Write a program that:  
\begin{itemize}  
\item Checks if input number is prime  
\item Uses nested loops and MOD function  
\item Optimizes loop range for efficiency  
\end{itemize}

\section{Exercise Answers: Loops in Fortran 77}

\subsection*{Problem 1: Basic DO Loop}
\begin{verbatim}
C     PRINTS NUMBERS 1 TO 10
      PROGRAM DO_LOOP
      INTEGER I
C     LOOP FROM 1 TO 10
      DO 10 I = 1, 10
          WRITE(*,*) I
10    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Loop variable \texttt{I} runs from 1 to 10
- \texttt{CONTINUE} at label 10 marks loop end
- Implicit increment of 1

\subsection*{Problem 2: Step Value Practice}
\begin{verbatim}
C     PRINTS EVEN NUMBERS 2-20
      PROGRAM EVENS
      INTEGER N
C     STEP BY 2
      DO 20 N = 2, 20, 2
          WRITE(*,*) N
20    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Step value 2 specified
- Loop ends at 20 (inclusive)
- Output: 2, 4, 6,..., 20

\subsection*{Problem 3: Nested Loop Grid}
\begin{verbatim}
C     PRINTS 3x3 GRID COORDINATES
      PROGRAM GRID
      INTEGER I, J
C     OUTER LOOP (ROWS)
      DO 30 I = 1, 3
C         INNER LOOP (COLUMNS)
          DO 40 J = 1, 3
              WRITE(*,*) '(', I, ',', J, ')'
40        CONTINUE
30    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
(1,1)
(1,2)
...
(3,3)
\end{verbatim}

\subsection*{Problem 4: Conditional Summation}
\begin{verbatim}
C     SUMS NUMBERS UNTIL >100
      PROGRAM SUM100
      INTEGER NUM, TOTAL
      TOTAL = 0
50    IF (TOTAL .LE. 100) THEN
          WRITE(*,*) 'Current total:', TOTAL
          WRITE(*,*) 'Enter number:'
          READ(*,*) NUM
          TOTAL = TOTAL + NUM
          GOTO 50
      END IF
      WRITE(*,*) 'Final total:', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Logic:}
- Loop continues while total â‰¤ 100
- User input inside loop
- \texttt{GOTO 50} creates repetition

\subsection*{Problem 5: Input Validation}
\begin{verbatim}
C     ENSURES POSITIVE INPUT
      PROGRAM VALIDATE
      REAL X
60    WRITE(*,*) 'Enter positive number:'
      READ(*,*) X
      IF (X .LE. 0.0) THEN
          WRITE(*,*) 'Invalid input!'
          GOTO 60
      END IF
      WRITE(*,*) 'Accepted:', X
      STOP
      END
\end{verbatim}
\textbf{Key Points:}
- Forces valid input using \texttt{GOTO}
- Loop continues until X > 0
- No explicit loop counter needed

\subsection*{Problem 6: Pattern Printing}
\begin{verbatim}
C     PRINTS RIGHT TRIANGLE PATTERN
      PROGRAM PATTERN
      INTEGER I, J
      DO 70 I = 1, 3
          DO 80 J = 1, I
              WRITE(*,*) '*'
80        CONTINUE
          WRITE(*,*) ' '  ! Newline
70    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
*
**
***
\end{verbatim}

\subsection*{Problem 7: Factorial Calculator}
\begin{verbatim}
C     CALCULATES N!
      PROGRAM FACT
      INTEGER N, I, FACTORIAL
      FACTORIAL = 1
      WRITE(*,*) 'Enter number:'
      READ(*,*) N
C     HANDLE 0! = 1 CASE
      IF (N .EQ. 0) GOTO 90
      DO 100 I = 1, N
          FACTORIAL = FACTORIAL * I
100   CONTINUE
90    WRITE(*,*) N, '! =', FACTORIAL
      STOP
      END
\end{verbatim}
\textbf{Note:}
- Special case for 0! handled
- Loop multiplies sequentially

\subsection*{Problem 8: Early Exit Loop}
\begin{verbatim}
C     SUMS POSITIVE NUMBERS
      PROGRAM SUM_POS
      INTEGER NUM, TOTAL
      TOTAL = 0
110   WRITE(*,*) 'Enter number (negative to stop):'
      READ(*,*) NUM
      IF (NUM .LT. 0) GOTO 120
      TOTAL = TOTAL + NUM
      GOTO 110
120   WRITE(*,*) 'Total:', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- \texttt{GOTO 120} exits on negative input
- Accumulates positive numbers
- Infinite loop until exit condition

\subsection*{Problem 9: Legacy Countdown}
\begin{verbatim}
C     COUNTDOWN USING ARITHMETIC IF
      PROGRAM LIFTOFF
      INTEGER K
      K = 5
130   WRITE(*,*) K
      K = K - 1
      IF (K) 140, 140, 130
140   WRITE(*,*) 'LIFTOFF!'
      STOP
      END
\end{verbatim}
\textbf{Output:}
\begin{verbatim}
5
4
3
2
1
LIFTOFF!
\end{verbatim}

\subsection*{Problem 10: Login System}
\begin{verbatim}
C     PASSWORD ATTEMPT SYSTEM
      PROGRAM LOGIN
      INTEGER TRIES, PASS
      TRIES = 3
      PASS = 1234
150   WRITE(*,*) 'Attempts left:', TRIES
      WRITE(*,*) 'Enter password:'
      READ(*,*) INPUT
      IF (INPUT .EQ. PASS) THEN
          WRITE(*,*) 'Access granted!'
          STOP
      END IF
      TRIES = TRIES - 1
      IF (TRIES .GT. 0) GOTO 150
      WRITE(*,*) 'Account locked!'
      STOP
      END
\end{verbatim}
\textbf{Features:}
- 3 attempt counter
- \texttt{GOTO} for loop control
- Checks password match

\subsection{Challenge Problem: Prime Checker}
\begin{verbatim}
C     CHECKS PRIME NUMBERS
      PROGRAM PRIME
      INTEGER N, I
      LOGICAL ISPRIME
      ISPRIME = .TRUE.
      WRITE(*,*) 'Enter number:'
      READ(*,*) N
C     CHECK DIVISORS UP TO SQRT(N)
      DO 160 I = 2, INT(SQRT(REAL(N)))
          IF (MOD(N, I) .EQ. 0) THEN
              ISPRIME = .FALSE.
              EXIT
          END IF
160   CONTINUE
      IF (ISPRIME) THEN
          WRITE(*,*) N, 'is prime'
      ELSE
          WRITE(*,*) N, 'is not prime'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Optimization:}
- Loops only up to square root of n
- Uses \texttt{EXIT} for early termination
- \texttt{MOD} checks divisibility

\chapter{Arrays in Fortran 77}

\section*{Introduction to Arrays}
Arrays allow storage and manipulation of multiple values of the same type. They are essential for handling datasets, matrices, and structured data. Fortran 77 supports static arrays with fixed sizes determined at compile time.

\section*{Declaring Arrays}
\subsection*{One-Dimensional Arrays}
\begin{verbatim}
C     DECLARING 1D ARRAYS
      PROGRAM ARRAY_DECLARE
      INTEGER NUMBERS(5)      ! 5-element integer array
      REAL    TEMPS(0:10)     ! 11 elements (0-10)
      LOGICAL FLAGS(3)        ! 3-element logical array
      CHARACTER*10 NAMES(4)   ! 4 strings of 10 chars each
      
      NUMBERS(1) = 10        ! Access first element
      TEMPS(0) = 23.5        ! Index starts at 0
      STOP
      END
\end{verbatim}

\subsection*{Multi-Dimensional Arrays}
\begin{verbatim}
C     2D ARRAY DECLARATION
      PROGRAM MATRIX_DECLARE
      REAL GRID(3,3)         ! 3x3 matrix
      INTEGER CUBE(2,2,2)    ! 2x2x2 3D array
      
      GRID(2,1) = 4.7       ! Row 2, Column 1
      STOP
      END
\end{verbatim}

\section*{Initializing Arrays}
\subsection*{DATA Statement}
\begin{verbatim}
C     COMPILE-TIME INITIALIZATION
      PROGRAM DATA_INIT
      INTEGER MARKS(5)
      DATA MARKS /85, 90, 78, 92, 88/
      
      REAL MATRIX(2,2)
      DATA MATRIX /1.0, 2.0, 3.0, 4.0/ ! Column-wise filling
      STOP
      END
\end{verbatim}

\subsection*{Runtime Initialization}
\begin{verbatim}
C     LOOP INITIALIZATION
      PROGRAM LOOP_INIT
      REAL SQUARES(10)
      INTEGER I
      
      DO 10 I = 1, 10
          SQUARES(I) = I**2
10    CONTINUE
      STOP
      END
\end{verbatim}

\section*{Accessing Array Elements}
\begin{verbatim}
C     MATRIX SUMMATION EXAMPLE
      PROGRAM MAT_SUM
      REAL A(3,3), TOTAL
      INTEGER I, J
      
C     Initialize matrix
      DO 20 I = 1, 3
          DO 30 J = 1, 3
              A(I,J) = I + J
30        CONTINUE
20    CONTINUE

C     Calculate sum
      TOTAL = 0.0
      DO 40 I = 1, 3
          DO 50 J = 1, 3
              TOTAL = TOTAL + A(I,J)
50        CONTINUE
40    CONTINUE
      WRITE(*,*) 'Total sum:', TOTAL
      STOP
      END
\end{verbatim}

\section{Passing Arrays to Subprograms}
\subsection{Main Program}
\begin{verbatim}
      PROGRAM MAIN
      INTEGER ARR(5)
      DATA ARR /1,2,3,4,5/
      CALL PRINT_ARRAY(ARR, 5)
      STOP
      END
\end{verbatim}

\subsection{Subroutine}
\begin{verbatim}
C     ADJUSTABLE ARRAY IN SUBROUTINE
      SUBROUTINE PRINT_ARRAY(A, N)
      INTEGER N, A(N)
      INTEGER I
      
      DO 60 I = 1, N
          WRITE(*,*) 'Element', I, '=', A(I)
60    CONTINUE
      RETURN
      END
\end{verbatim}

\section{Array Operations}
\subsection*{Element-wise Operations}
\begin{verbatim}
C     VECTOR ADDITION
      PROGRAM VEC_ADD
      REAL V1(5), V2(5), RESULT(5)
      INTEGER I
      
C     Initialize vectors
      DO 70 I = 1, 5
          V1(I) = I
          V2(I) = I*2
70    CONTINUE

C     Perform addition
      DO 80 I = 1, 5
          RESULT(I) = V1(I) + V2(I)
80    CONTINUE
      STOP
      END
\end{verbatim}

\section{Common Pitfalls}
\begin{itemize}
\item \textbf{Out-of-Bounds Access:}
\begin{verbatim}
INTEGER ARR(5)
ARR(6) = 10  ! Undefined behavior
\end{verbatim}

\item \textbf{Column-Major Order:}
\begin{verbatim}
REAL MAT(100,100)
! More efficient:
DO 100 J = 1, 100   ! Columns outer loop
    DO 200 I = 1, 100
        MAT(I,J) = ...
200 CONTINUE
100 CONTINUE
\end{verbatim}

\item \textbf{Size Mismatch:}
\begin{verbatim}
CALL SUB(ARR(5)) when SUB expects ARR(10)
\end{verbatim}
\end{itemize}

\section{Best Practices}
\begin{itemize}
\item Use PARAMETER for array sizes:
\begin{verbatim}
INTEGER, PARAMETER :: SIZE = 100
REAL DATA(SIZE)
\end{verbatim}

\item Initialize arrays explicitly
\item Comment array dimensions and purposes
\item Prefer column-wise iteration for matrices
\end{itemize}

\section*{Advanced Example: Matrix Multiplication}
\begin{verbatim}
C     MATRIX MULTIPLICATION
      PROGRAM MAT_MUL
      REAL A(2,2), B(2,2), C(2,2)
      INTEGER I, J, K
      
C     Initialize matrices
      DATA A /1.0, 2.0, 3.0, 4.0/
      DATA B /5.0, 6.0, 7.0, 8.0/

C     Perform multiplication
      DO 300 I = 1, 2
          DO 400 J = 1, 2
              C(I,J) = 0.0
              DO 500 K = 1, 2
                  C(I,J) = C(I,J) + A(I,K)*B(K,J)
500           CONTINUE
400       CONTINUE
300   CONTINUE

C     Print result
      WRITE(*,*) 'Product matrix:'
      DO 600 I = 1, 2
          WRITE(*,*) C(I,1), C(I,2)
600   CONTINUE
      STOP
      END
\end{verbatim}

\section{Array and Matrix Declaration \& Access in Fortran 77}

\subsection*{1. Fundamental Array Types}
Fortran 77 supports several array declaration styles, each with specific use cases:

\subsubsection*{Explicit-Shape Arrays}
\begin{itemize}
\item \textbf{Purpose}: Fixed-size arrays with compile-time dimensions
\item \textbf{Syntax}: 
\begin{verbatim}
DATA_TYPE NAME(LOWER:UPPER, ...)
\end{verbatim}
\item \textbf{Key Features}:
  - Dimensions specified with explicit bounds
  - Most common array type
  - Memory allocated at program start
\end{itemize}

\begin{verbatim}
C 1D: 5 elements (indices 1-5)
INTEGER SCORES(5)       

C 2D: 3x4 matrix (rows 1-3, cols 1-4)
REAL TEMPERATURES(3,4)  

C Custom bounds: indices 0-10 (11 elements)
CHARACTER*20 NAMES(0:10)
\end{verbatim}

\subsubsection*{Adjustable Arrays}
\begin{itemize}
\item \textbf{Purpose}: Pass array sections to subprograms
\item \textbf{Syntax}: 
\begin{verbatim}
DATA_TYPE NAME(*)
\end{verbatim}
\item \textbf{Key Features}:
  - Used in subprogram parameter lists
  - Size determined by calling program
  - Requires explicit interface in some cases
\end{itemize}

\begin{verbatim}
SUBROUTINE PROCESS(VECTOR, N)
INTEGER N, VECTOR(N)  ! Adjustable size
...
END
\end{verbatim}

\subsubsection*{Assumed-Size Arrays}
\begin{itemize}
\item \textbf{Purpose}: Handle arrays of unknown size
\item \textbf{Syntax}: 
\begin{verbatim}
DATA_TYPE NAME(*)
\end{verbatim}
\item \textbf{Key Features}:
  - Last dimension can be asterisk
  - Limited to subprogram parameters
  - Avoid for complex operations
\end{itemize}

\begin{verbatim}
SUBROUTINE PRINT_ARRAY(ARR, SIZE)
REAL ARR(*)  ! Assumed-size array
...
END
\end{verbatim}

\subsection*{2. Matrix Declaration Techniques}
\subsubsection*{Row vs Column Major Order}
Fortran uses \textbf{column-major} storage:
\begin{itemize}
\item Elements stored column-wise in memory
\item Critical for performance optimization
\item Affects loop nesting order
\end{itemize}

\begin{verbatim}
REAL MATRIX(3,3)  ! Stored as:
! (1,1), (2,1), (3,1), (1,2), (2,2), ...
\end{verbatim}

\subsubsection*{Multi-Dimensional Arrays}
\begin{itemize}
\item Created by specifying multiple dimensions
\item Maximum 7 dimensions (per standard)
\item Higher dimensions less common
\end{itemize}

\begin{verbatim}
C 3D: 2x3x4 array
INTEGER CUBE(2,3,4)

C 4D: Time-varying 3D data
REAL SPACETIME(10,10,10,100)
\end{verbatim}

\subsection*{3. Array Access Methods}
\subsubsection*{Element Access}
\begin{itemize}
\item Use \texttt{( )} with comma-separated indices
\item Indices must be within declared bounds
\item No automatic bounds checking
\end{itemize}

\begin{verbatim}
REAL GRID(5,5)
GRID(2,3) = 4.5  ! Single element
\end{verbatim}

\subsubsection*{Section Access (Subarrays)}
\begin{itemize}
\item Access contiguous array portions
\item Limited to \textit{start:end:step} syntax
\item Fortran 77 requires explicit loops
\end{itemize}

\begin{verbatim}
INTEGER ARR(10), SUB(5)
DO 10 I = 1,5
    SUB(I) = ARR(I+2)  ! Elements 3-7
10 CONTINUE
\end{verbatim}

\subsection*{4. Special Array Cases}
\subsubsection*{Zero-Based Arrays}
\begin{itemize}
\item Not required to start at 1
\item Useful for mathematical indices
\end{itemize}

\begin{verbatim}
REAL WAVE(-100:100)  ! 201 elements
WAVE(-100) = 0.0     ! First element
\end{verbatim}

\subsubsection*{Character Arrays}
\begin{itemize}
\item Arrays of fixed-length strings
\item Different from character arrays in C
\end{itemize}

\begin{verbatim}
CHARACTER*15 NAMES(50)  ! 50 names, 15 chars each
NAMES(1)(1:5) = 'John '  ! Access substring
\end{verbatim}

\subsection*{5. Array Usage in Subprograms}
\subsubsection*{Passing Full Arrays}
\begin{itemize}
\item Pass array name without indices
\item Actual and dummy arrays must match rank
\end{itemize}

\begin{verbatim}
CALL PRINT_MATRIX(MATRIX)  ! Main program

SUBROUTINE PRINT_MATRIX(ARR)
REAL ARR(3,3)  ! Must match dimensions
...
END
\end{verbatim}

\subsubsection*{Common Pitfalls}
\begin{itemize}
\item \textbf{Dimension Mismatch}: 
\begin{verbatim}
REAL A(5)
CALL SUB(A(2))  ! Passing single element
\end{verbatim}

\item \textbf{Assumed-Size Limitations}:
\begin{verbatim}
SUBROUTINE BAD(ARR)
REAL ARR(*)  
PRINT *, SIZE(ARR)  ! Undefined!
END
\end{verbatim}
\end{itemize}

\subsection*{6. Best Practices}
\begin{itemize}
\item \textbf{Use PARAMETER Constants}:
\begin{verbatim}
INTEGER, PARAMETER :: N = 100
REAL DATA(N,N)
\end{verbatim}

\item \textbf{Initialize Explicitly}:
\begin{verbatim}
REAL VECTOR(5)
DATA VECTOR /5*0.0/  ! Initialize to zero
\end{verbatim}

\item \textbf{Column-Major Optimization}:
\begin{verbatim}
DO 20 J = 1, COLS    ! Outer loop columns
    DO 30 I = 1, ROWS
        MATRIX(I,J) = ...
30  CONTINUE
20 CONTINUE
\end{verbatim}
\end{itemize}

\subsection*{7. Comprehensive Example}
\begin{verbatim}
C MATRIX-VECTOR MULTIPLICATION
      PROGRAM MATVEC
      REAL MAT(3,3), VEC(3), RESULT(3)
      INTEGER I,J
      
C Initialize matrix (column-wise)
      DATA MAT /1.0, 4.0, 7.0,   ! First column
     *          2.0, 5.0, 8.0,   ! Second column
     *          3.0, 6.0, 9.0/    ! Third column
     
C Initialize vector
      DATA VEC /1.0, 2.0, 3.0/

C Perform multiplication
      DO 40 I = 1, 3
          RESULT(I) = 0.0
          DO 50 J = 1, 3
              RESULT(I) = RESULT(I) + MAT(I,J)*VEC(J)
50        CONTINUE
40    CONTINUE

      WRITE(*,*) 'Result:', RESULT
      STOP
      END
\end{verbatim}

\textbf{Key Observations}:
1. Matrix initialized column-wise via DATA
2. Nested loops follow column-major order
3. Explicit element-by-element calculation
4. RESULT array stores final values

\section{Exercises: Loops in Fortran 77}

\subsection*{Basic Loop Structures}
1. **Simple DO Loop**:  
Write a program to print numbers from 1 to a user-input integer \( N \) using a DO loop.  
*Input*: 5 | *Output*: 1 2 3 4 5  

2. **Step Value Practice**:  
Modify the above program to print even numbers between 2 and \( N \) using a step value of 2.  
*Input*: 10 | *Output*: 2 4 6 8 10  

3. **Summation Loop**:  
Calculate the sum of the first \( N \) natural numbers using a DO loop.  
*Input*: 5 | *Output*: 15  

4. **Factorial Calculator**:  
Compute \( N! \) (factorial) using a DO loop. Handle \( N = 0 \) as a special case.  
*Input*: 4 | *Output*: 24  

\subsection*{Conditional Loops \& Control Flow}  
5. **Input Validation**:  
Use a DO-WHILE loop to repeatedly ask for a positive integer until valid input is received.  

6. **Early Exit**:  
Read numbers until a negative value is entered. Print the sum of positive numbers using a loop with a conditional `GOTO` exit.  
*Input*: 3 5 -1 | *Output*: 8  

7. **Prime Checker**:  
Check if a number is prime using a loop. Terminate early if a divisor is found.  
*Input*: 7 | *Output*: "Prime"  

8. **Password Attempts**:  
Implement 3 login attempts using a loop. Exit early if the correct password is entered.  

\subsection*{Nested Loops}  
9. **Multiplication Table**:  
Print a \( N \times N \) multiplication table using nested loops.  
*Input*: 3 | *Output*:  
1 2 3  
2 4 6  
3 6 9  

10. **Pattern Printing**:  
Use nested loops to print:  
\begin{verbatim}
*
**
***
\end{verbatim}  

11. **Matrix Initialization**:  
Initialize a \( 3 \times 3 \) matrix with values \( A(i,j) = i + j \) using nested loops.  

\subsection*{Array Operations with Loops}  
12. **Array Sum \& Average**:  
Read 5 numbers into an array. Compute their sum and average using a loop.  

13. **Maximum Element**:  
Find the largest value in a 1D array of 10 elements using a loop.  

14. **Array Reversal**:  
Reverse the elements of a 1D array using loops.  
*Input*: [1, 2, 3] | *Output*: [3, 2, 1]  

15. **Matrix Transpose**:  
Transpose a \( 3 \times 3 \) matrix using nested loops.  
*Input*:  
1 2 3  
4 5 6  
7 8 9  
*Output*:  
1 4 7  
2 5 8  
3 6 9  

\subsection*{Challenge Problem}  
**Bubble Sort**: Sort a 1D array of 10 integers in ascending order using nested loops.  

\section{Exercise Answers: Loops in Fortran 77}

\subsection*{1. Simple DO Loop}
\begin{verbatim}
C     PRINTS NUMBERS 1 TO N
      PROGRAM COUNT
      INTEGER N, I
      WRITE(*,*) 'ENTER N:'
      READ(*,*) N
      DO 10 I = 1, N
          WRITE(*,*) I
10    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- Loop variable \texttt{I} runs from 1 to user-input \texttt{N}
- \texttt{CONTINUE} at label 10 marks loop end
- Implicit increment of 1 per iteration

\subsection*{2. Even Numbers with Step Value}
\begin{verbatim}
C     PRINTS EVEN NUMBERS UPTO N
      PROGRAM EVENS
      INTEGER N, I
      WRITE(*,*) 'ENTER N:'
      READ(*,*) N
      DO 20 I = 2, N, 2
          WRITE(*,*) I
20    CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Key Features:}
- Step value 2 creates even sequence
- Handles any even/odd \texttt{N} correctly
- Loop bounds inclusive

\subsection*{3. Sum of First N Natural Numbers}
\begin{verbatim}
C     CALCULATES SUM(1-N)
      PROGRAM SUMN
      INTEGER N, I, TOTAL
      TOTAL = 0
      WRITE(*,*) 'ENTER N:'
      READ(*,*) N
      DO 30 I = 1, N
          TOTAL = TOTAL + I
30    CONTINUE
      WRITE(*,*) 'SUM:', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Logic:}
- Initializes \texttt{TOTAL} to 0
- Accumulates sum in loop
- Works for N â‰¥ 0

\subsection*{4. Factorial Calculator}
\begin{verbatim}
C     COMPUTES N!
      PROGRAM FACT
      INTEGER N, I, RESULT
      RESULT = 1
      WRITE(*,*) 'ENTER N:'
      READ(*,*) N
      IF (N .EQ. 0) GOTO 40
      DO 50 I = 1, N
          RESULT = RESULT * I
50    CONTINUE
40    WRITE(*,*) N, '! =', RESULT
      STOP
      END
\end{verbatim}
\textbf{Special Case:}
- Handles 0! = 1 via \texttt{GOTO}
- Loop multiplies sequentially
- Result initialized to 1

\subsection*{5. Input Validation}
\begin{verbatim}
C     ENSURES POSITIVE INPUT
      PROGRAM VALID
      INTEGER NUM
60    WRITE(*,*) 'ENTER POSITIVE NUMBER:'
      READ(*,*) NUM
      IF (NUM .LE. 0) GOTO 60
      WRITE(*,*) 'VALID INPUT:', NUM
      STOP
      END
\end{verbatim}
\textbf{Features:}
- Infinite loop until valid input
- \texttt{GOTO} creates repetition
- Strict positive check

\subsection*{6. Early Exit Summation}
\begin{verbatim}
C     SUMS POSITIVE NUMBERS
      PROGRAM SUM_POS
      INTEGER NUM, TOTAL
      TOTAL = 0
70    WRITE(*,*) 'ENTER NUMBER:'
      READ(*,*) NUM
      IF (NUM .LT. 0) GOTO 80
      TOTAL = TOTAL + NUM
      GOTO 70
80    WRITE(*,*) 'TOTAL:', TOTAL
      STOP
      END
\end{verbatim}
\textbf{Control Flow:}
- Loop exits on negative input
- Accumulates in \texttt{TOTAL}
- \texttt{GOTO} creates loop structure

\subsection*{7. Prime Number Check}
\begin{verbatim}
C     CHECKS PRIME STATUS
      PROGRAM PRIME
      INTEGER N, I
      LOGICAL ISPRIME
      ISPRIME = .TRUE.
      WRITE(*,*) 'ENTER NUMBER:'
      READ(*,*) N
      DO 90 I = 2, INT(SQRT(REAL(N)))
          IF (MOD(N, I) .EQ. 0) THEN
              ISPRIME = .FALSE.
              GOTO 100
          END IF
90    CONTINUE
100   IF (ISPRIME) THEN
          WRITE(*,*) 'PRIME'
      ELSE
          WRITE(*,*) 'NOT PRIME'
      END IF
      STOP
      END
\end{verbatim}
\textbf{Optimization:}
- Loops up to âˆšn
- Early exit using \texttt{GOTO}
- Handles 1 and 2 correctly

\subsection*{8. Password Attempt System}
\begin{verbatim}
C     PASSWORD CHECKER
      PROGRAM PASS
      INTEGER TRIES, PASS, INPUT
      TRIES = 3
      PASS = 1234
110   WRITE(*,*) 'ATTEMPTS LEFT:', TRIES
      WRITE(*,*) 'ENTER PASSWORD:'
      READ(*,*) INPUT
      IF (INPUT .EQ. PASS) THEN
          WRITE(*,*) 'ACCESS GRANTED'
          STOP
      ELSE
          TRIES = TRIES - 1
          IF (TRIES .GT. 0) GOTO 110
      END IF
      WRITE(*,*) 'ACCOUNT LOCKED'
      STOP
      END
\end{verbatim}
\textbf{Security:}
- 3 attempt counter
- Decrements on wrong attempts
- Immediate exit on correct password

\subsection*{9. Multiplication Table}
\begin{verbatim}
C     N x N MULTIPLICATION TABLE
      PROGRAM MUL_TABLE
      INTEGER N, I, J
      WRITE(*,*) 'ENTER N:'
      READ(*,*) N
      DO 120 I = 1, N
          DO 130 J = 1, N
              WRITE(*,'(I4)') I*J
130       CONTINUE
          WRITE(*,*) ' '  ! NEWLINE
120   CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Formatting:}
- Nested loops for rows/columns
- Formatted output for alignment
- Newline after each row

\subsection*{10. Star Pattern}
\begin{verbatim}
C     PRINTS TRIANGLE PATTERN
      PROGRAM STAR
      INTEGER I, J
      DO 140 I = 1, 3
          DO 150 J = 1, I
              WRITE(*,*) '*'
150       CONTINUE
          WRITE(*,*) ' '  ! NEWLINE
140   CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Pattern Logic:}
- Outer loop controls rows
- Inner loop prints stars per row
- Newline after each row

\subsection*{11. Matrix Initialization}
\begin{verbatim}
C     INITIALIZES 3x3 MATRIX
      PROGRAM MAT_INIT
      INTEGER MAT(3,3), I, J
      DO 160 I = 1, 3
          DO 170 J = 1, 3
              MAT(I,J) = I + J
170       CONTINUE
160   CONTINUE
      STOP
      END
\end{verbatim}
\textbf{Structure:}
- Nested loops for rows/columns
- Formula: \texttt{I + J}
- 3x3 matrix dimensions

\subsection*{12. Array Sum \& Average}
\begin{verbatim}
C     ARRAY OPERATIONS
      PROGRAM ARR_OPS
      REAL ARR(5), SUM, AVG
      INTEGER I
      WRITE(*,*) 'ENTER 5 NUMBERS:'
      READ(*,*) (ARR(I), I=1,5)
      SUM = 0.0
      DO 180 I = 1, 5
          SUM = SUM + ARR(I)
180   CONTINUE
      AVG = SUM / 5.0
      WRITE(*,*) 'SUM:', SUM, 'AVG:', AVG
      STOP
      END
\end{verbatim}
\textbf{Array Handling:}
- Implied DO loop for input
- Accumulates sum in loop
- Explicit type conversion for average

\subsection*{13. Maximum Element}
\begin{verbatim}
C     FINDS LARGEST ARRAY ELEMENT
      PROGRAM MAXVAL
      REAL ARR(10), MAX
      INTEGER I
      READ(*,*) ARR
      MAX = ARR(1)
      DO 190 I = 2, 10
          IF (ARR(I) .GT. MAX) MAX = ARR(I)
190   CONTINUE
      WRITE(*,*) 'MAXIMUM:', MAX
      STOP
      END
\end{verbatim}
\textbf{Algorithm:}
- Initialize max to first element
- Linear scan through array
- Updates max when larger found

\subsection*{14. Array Reversal}
\begin{verbatim}
C     REVERSES ARRAY IN-PLACE
      PROGRAM REVERSE
      INTEGER ARR(5), TEMP, I
      DATA ARR /1,2,3,4,5/
      DO 200 I = 1, 2
          TEMP = ARR(I)
          ARR(I) = ARR(6-I)
          ARR(6-I) = TEMP
200   CONTINUE
      WRITE(*,*) ARR
      STOP
      END
\end{verbatim}
\textbf{Swap Logic:}
- Swaps elements from ends to center
- Loop runs halfway (N/2 iterations)
- Temporary variable for swap

\subsection*{15. Matrix Transpose}
\begin{verbatim}
C     TRANSPOSES 3x3 MATRIX
      PROGRAM TRANSPOSE
      INTEGER A(3,3), B(3,3), I, J
      READ(*,*) ((A(I,J), J=1,3), I=1,3)
      DO 210 I = 1, 3
          DO 220 J = 1, 3
              B(J,I) = A(I,J)
220       CONTINUE
210   CONTINUE
      WRITE(*,*) 'TRANSPOSE:'
      WRITE(*,*) ((B(I,J), J=1,3), I=1,3)
      STOP
      END
\end{verbatim}
\textbf{Transposition:}
- Creates new matrix \texttt{B}
- Swaps row/column indices
- Nested input/output loops

\subsection*{Challenge: Bubble Sort}
\begin{verbatim}
C     SORTS ARRAY IN ASCENDING ORDER
      PROGRAM BUBBLE
      INTEGER ARR(10), I, J, TEMP
      LOGICAL SWAPPED
      READ(*,*) ARR
      DO 230 I = 9, 1, -1
          SWAPPED = .FALSE.
          DO 240 J = 1, I
              IF (ARR(J) .GT. ARR(J+1)) THEN
                  TEMP = ARR(J)
                  ARR(J) = ARR(J+1)
                  ARR(J+1) = TEMP
                  SWAPPED = .TRUE.
              END IF
240       CONTINUE
          IF (.NOT. SWAPPED) GOTO 250
230   CONTINUE
250   WRITE(*,*) 'SORTED ARRAY:', ARR
      STOP
      END
\end{verbatim}
\textbf{Optimization:}
- Early exit if no swaps
- Outer loop reduces range
- In-place sorting

\chapter{Functions in Fortran 77}

\subsection*{Introduction to Functions}
Functions in Fortran 77 are subprograms that:
\begin{itemize}
\item Return a single value
\item Can accept input arguments
\item Improve code modularity and reusability
\item Are categorized as:
  \begin{itemize}
  \item Intrinsic (built-in)
  \item External (user-defined)
  \item Statement (single-expression)
  \end{itemize}
\end{itemize}

\subsection*{1. Intrinsic Functions}
Predefined by the language:
\begin{verbatim}
C     EXAMPLE OF INTRINSIC FUNCTIONS
      PROGRAM INTRINSIC
      REAL X, Y
      X = 2.5
      Y = SQRT(X)      ! Square root
      WRITE(*,*) SIN(X), EXP(Y)  ! Sine and exponential
      STOP
      END
\end{verbatim}

\subsection*{2. External Functions}
User-defined functions in separate program units:

\subsubsection*{Function Definition}
\begin{verbatim}
C     FUNCTION TO CALCULATE AREA OF CIRCLE
      REAL FUNCTION AREA(R)
      REAL R, PI
      PARAMETER (PI = 3.14159)
      AREA = PI * R**2
      RETURN
      END
\end{verbatim}

\subsubsection*{Function Usage}
\begin{verbatim}
C     MAIN PROGRAM
      PROGRAM MAIN
      REAL RADIUS, AREA
      WRITE(*,*) 'ENTER RADIUS:'
      READ(*,*) RADIUS
      WRITE(*,*) 'AREA:', AREA(RADIUS)
      STOP
      END
\end{verbatim}

\subsection*{3. Statement Functions}
Single-line functions defined in declaration section:
\begin{verbatim}
C     SIMPLE STATEMENT FUNCTION
      PROGRAM STMT
      REAL X, Y, AVG
      AVG(A,B) = (A + B)/2.0  ! Statement function
      
      X = 5.0
      Y = 7.0
      WRITE(*,*) 'AVERAGE:', AVG(X,Y)
      STOP
      END
\end{verbatim}

\subsection*{Function Declaration Rules}
\begin{itemize}
\item Return type declared in function definition
\begin{verbatim}
REAL FUNCTION NAME(...)
\end{verbatim}
\item Must be declared in calling program if:
  \begin{itemize}
  \item Return type doesn't match implicit naming
  \item Function is external
  \end{itemize}
\item Arguments passed by reference
\end{itemize}

\subsection*{Argument Passing Example}
\begin{verbatim}
C     FUNCTION WITH MULTIPLE PARAMETERS
      REAL FUNCTION POWER(BASE, EXP)
      REAL BASE
      INTEGER EXP
      POWER = BASE**EXP
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL POWER, RESULT
      RESULT = POWER(2.5, 3)
      WRITE(*,*) '2.5^3 =', RESULT
      STOP
      END
\end{verbatim}

\subsection*{4. Type Declaration in Calling Program}
\begin{verbatim}
C     EXPLICIT TYPE DECLARATION
      PROGRAM TYPE_DEC
      REAL VOLUME  ! Function returns REAL
      WRITE(*,*) 'VOLUME:', VOLUME(5.0)
      STOP
      END

      REAL FUNCTION VOLUME(R)
      REAL R
      VOLUME = (4.0/3.0) * 3.14159 * R**3
      RETURN
      END
\end{verbatim}

\subsection*{5. Common Function Errors}
\begin{itemize}
\item \textbf{Implicit Type Mismatch}:
\begin{verbatim}
FUNCTION TEST()  ! Implicit REAL
...
INTEGER TEST    ! Conflict in calling program
\end{verbatim}

\item \textbf{Missing Declaration}:
\begin{verbatim}
C     MAIN PROGRAM
      PROGRAM ERR
      WRITE(*,*) FUNC(2)  ! FUNC not declared
      STOP
      END

      INTEGER FUNCTION FUNC(X)
...
\end{verbatim}

\item \textbf{Argument Count Mismatch}:
\begin{verbatim}
CALL AREA(5.0, RESULT)  ! AREA expects 1 argument
\end{verbatim}
\end{itemize}

\subsection*{6. Functions vs Subroutines}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Functions} & \textbf{Subroutines} \\ 
\hline
Return one value & No return value \\
Used in expressions & Called with CALL \\
Can't modify arguments & Can modify arguments \\
\hline
\end{tabular}
\end{center}

\subsection*{7. Best Practices}
\begin{itemize}
\item Always declare function return types explicitly
\item Use meaningful function names
\item Document argument types and purposes
\item Avoid modifying input arguments
\item Use statement functions only for simple operations
\end{itemize}

\subsection*{8. Advanced Example}
\begin{verbatim}
C     RECURSIVE FACTORIAL (SIMULATED)
      PROGRAM RECUR
      INTEGER N, FACT
      WRITE(*,*) 'ENTER NUMBER:'
      READ(*,*) N
      WRITE(*,*) N, '! =', FACT(N)
      STOP
      END

      INTEGER FUNCTION FACT(K)
      INTEGER K
      IF (K .LE. 1) THEN
          FACT = 1
      ELSE
          FACT = K * FACT(K-1)
      END IF
      RETURN
      END
\end{verbatim}
\textbf{Note:} Fortran 77 doesn't officially support recursion - this may require compiler-specific settings.

\subsection*{9. Function Libraries}
Group related functions into files:
\begin{verbatim}
C     MATH_OPERATIONS.F
      REAL FUNCTION AREA(R)
      ...
      END

      REAL FUNCTION VOLUME(R)
      ...
      END
\end{verbatim}
Include in main program:
\begin{verbatim}
      PROGRAM GEOM
      REAL AREA, VOLUME
      ...
      END
\end{verbatim}
\section{Implicit vs. Explicit Functions in Fortran 77}

\subsection*{1. Implicit Functions}
Functions that rely on Fortran's default typing rules, where:
\begin{itemize}
\item Function type is determined by first letter of name
\item I-N: INTEGER (default)
\item A-H, O-Z: REAL (default)
\item No explicit type declaration required
\end{itemize}

\subsubsection*{Example 1: Implicit Real Function}
\begin{verbatim}
C     IMPLICIT REAL FUNCTION (NAME STARTS WITH 'A')
      FUNCTION AVG(X, Y)
      AVG = (X + Y) / 2.0
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      WRITE(*,*) 'AVERAGE:', AVG(5.0, 7.0)
      STOP
      END
\end{verbatim}
\textbf{Behavior:}
- Function name 'AVG' starts with A â†’ REAL
- No type declaration in function definition
- Works but prone to errors

\subsubsection*{Example 2: Implicit Integer Function}
\begin{verbatim}
C     IMPLICIT INTEGER FUNCTION (NAME STARTS WITH 'I')
      FUNCTION ICOUNT(X)
      ICOUNT = INT(X) + 5
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      WRITE(*,*) 'COUNT:', ICOUNT(3.7)  ! Output: 8
      STOP
      END
\end{verbatim}
\textbf{Risk:}
- Return type inferred from name
- Easy to create type mismatches

\subsection*{2. Explicit Functions}
Functions with declared return types:
\begin{itemize}
\item Type specified in function definition
\item Must be declared in calling program
\item Recommended for code clarity
\end{itemize}

\subsubsection*{Example 1: Explicit Real Function}
\begin{verbatim}
C     EXPLICIT TYPE DECLARATION
      REAL FUNCTION AREA(R)
      REAL R, PI
      PARAMETER (PI = 3.14159)
      AREA = PI * R**2
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL AREA  ! MUST DECLARE IN CALLING UNIT
      WRITE(*,*) 'AREA:', AREA(2.5)
      STOP
      END
\end{verbatim}
\textbf{Advantages:}
- Clear return type declaration
- Compiler checks type consistency
- Avoids naming conflicts

\subsubsection*{Example 2: Explicit Integer Function}
\begin{verbatim}
C     EXPLICIT INTEGER FUNCTION
      INTEGER FUNCTION FACT(N)
      INTEGER N, I
      FACT = 1
      DO 10 I = 1, N
          FACT = FACT * I
10    CONTINUE
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      INTEGER FACT  ! REQUIRED DECLARATION
      WRITE(*,*) '5! =', FACT(5)
      STOP
      END
\end{verbatim}

\subsection*{3. Key Differences}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Feature} & \textbf{Implicit} & \textbf{Explicit} \\ 
\hline
Declaration & Name-based & Explicit \\
Type Safety & Low & High \\
Readability & Poor & Good \\
Error Checking & Limited & Strict \\
Legacy Code & Common & Rare \\
\hline
\end{tabular}
\end{center}

\subsection*{4. Common Pitfalls with Implicit Functions}
\subsubsection*{Type Mismatch Example}
\begin{verbatim}
C     DANGEROUS IMPLICIT CONVERSION
      FUNCTION TOTAL(X, Y)
      TOTAL = X + Y  ! Implicit REAL return
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      INTEGER TOTAL  ! WRONG TYPE DECLARATION
      WRITE(*,*) TOTAL(2, 3)  ! Output: 0 (incorrect)
      STOP
      END
\end{verbatim}
\textbf{Result:}
- Function returns REAL but main program expects INTEGER
- Undefined behavior occurs

\subsubsection*{Fixing with Explicit Declaration}
\begin{verbatim}
      REAL FUNCTION TOTAL(X, Y)
      INTEGER X, Y
      TOTAL = REAL(X) + REAL(Y)
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL TOTAL  ! CORRECT DECLARATION
      WRITE(*,*) TOTAL(2, 3)  ! Output: 5.0
      STOP
      END
\end{verbatim}

\subsection*{5. Best Practices}
\begin{itemize}
\item \textbf{Always Use Explicit Functions}:
\begin{verbatim}
REAL FUNCTION NAME(...)  ! Preferred
\end{verbatim}

\item \textbf{Use IMPLICIT NONE}:
\begin{verbatim}
PROGRAM MAIN
IMPLICIT NONE  ! Disables default typing
REAL :: VALUE
...
END
\end{verbatim}

\item \textbf{Declare Functions in Calling Units}:
\begin{verbatim}
PROGRAM MAIN
REAL EXTERNAL_FUNC  ! Declaration
...
END
\end{verbatim}

\item \textbf{Document Function Interfaces}:
\begin{verbatim}
C     FUNCTION: CALCULATE_VELOCITY
C     INPUT: MASS (REAL), FORCE (REAL)
C     OUTPUT: VELOCITY (REAL)
      REAL FUNCTION VELOCITY(MASS, FORCE)
      ...
\end{verbatim}
\end{itemize}

\subsection*{6. Advanced Example: Type Conversion}
\begin{verbatim}
C     EXPLICIT TYPE CONVERSION FUNCTION
      CHARACTER*20 FUNCTION STR(NUM)
      REAL NUM
      WRITE(STR, '(F10.2)') NUM
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      CHARACTER*20 STR
      WRITE(*,*) 'FORMATTED:', STR(123.456)
      STOP
      END
\end{verbatim}
\textbf{Output:} \texttt{123.46}

\subsection*{7. Function Type Declaration Table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Declaration} & \textbf{Return Type} & \textbf{Example} \\ 
\hline
REAL FUNCTION & Single-precision & REAL FUNC() \\
DOUBLE PRECISION & Double-precision & DOUBLE PRECISION DFUNC() \\
INTEGER FUNCTION & Integer & INTEGER IFUNC() \\
LOGICAL FUNCTION & Boolean & LOGICAL TEST() \\
CHARACTER*N & String & CHARACTER*10 CFUNC() \\
\hline
\end{tabular}
\end{center}

\subsection*{8. Conversion Checklist}
When converting implicit to explicit:
\begin{enumerate}
\item Add explicit type declaration to function
\item Declare function in all calling units
\item Check argument types match
\item Use IMPLICIT NONE to catch errors
\item Test with edge cases
\end{enumerate}

\section{More Functions vs. Subroutines in Fortran 77}

\subsection*{1. Fundamental Definitions}
\begin{itemize}
\item \textbf{Function}:
  - Returns a single value
  - Invoked within expressions
  - Typically used for calculations
  - Example: \texttt{SQRT(X)}, \texttt{SIN(X)}

\item \textbf{Subroutine}:
  - Does not return a value directly
  - Invoked with \texttt{CALL} statement
  - Can modify multiple arguments
  - Example: \texttt{CALL SWAP(A, B)}
\end{itemize}

\subsection*{2. Key Differences}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Feature} & \textbf{Function} & \textbf{Subroutine} \\ 
\hline
Return Value & Single value & None (void) \\
Invocation & In expressions & With \texttt{CALL} \\
Arguments & Input parameters & Input/Output parameters \\
Side Effects & Should avoid & Expected \\
Return Method & Assign to function name & Modify arguments \\
Multiple Returns & Impossible & Possible via arguments \\
\hline
\end{tabular}
\end{center}

\subsection*{3. Function Examples}
\subsubsection*{Example 1: Basic Function}
\begin{verbatim}
C     FUNCTION TO CALCULATE AREA
      REAL FUNCTION AREA(R)
      REAL R, PI
      PARAMETER (PI = 3.14159)
      AREA = PI * R**2
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL AREA, RADIUS
      RADIUS = 5.0
      WRITE(*,*) 'AREA:', AREA(RADIUS)
      STOP
      END
\end{verbatim}

\subsubsection*{Example 2: Type-Specific Function}
\begin{verbatim}
C     INTEGER FUNCTION
      INTEGER FUNCTION IFACT(N)
      INTEGER N, I
      IFACT = 1
      DO 10 I = 1, N
          IFACT = IFACT * I
10    CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{4. Subroutine Examples}
\subsubsection*{Example 1: Basic Subroutine}
\begin{verbatim}
C     SUBROUTINE TO SWAP VALUES
      SUBROUTINE SWAP(A, B)
      REAL A, B, TEMP
      TEMP = A
      A = B
      B = TEMP
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL X, Y
      X = 5.0
      Y = 10.0
      CALL SWAP(X, Y)
      WRITE(*,*) 'X=', X, 'Y=', Y
      STOP
      END
\end{verbatim}

\subsubsection*{Example 2: Multi-Output Subroutine}
\begin{verbatim}
C     CALCULATE STATISTICS
      SUBROUTINE STATS(ARR, N, AVG, MAX)
      REAL ARR(N), AVG, MAX
      INTEGER N, I
      AVG = 0.0
      MAX = ARR(1)
      DO 20 I = 1, N
          AVG = AVG + ARR(I)
          IF (ARR(I) .GT. MAX) MAX = ARR(I)
20    CONTINUE
      AVG = AVG / REAL(N)
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL NUMBERS(5), AVERAGE, MAXIMUM
      DATA NUMBERS /2.0, 5.0, 7.0, 3.0, 1.0/
      CALL STATS(NUMBERS, 5, AVERAGE, MAXIMUM)
      WRITE(*,*) 'AVG:', AVERAGE, 'MAX:', MAXIMUM
      STOP
      END
\end{verbatim}

\subsection*{5. Argument Handling Comparison}
\subsubsection*{Function Argument Handling}
\begin{verbatim}
C     FUNCTION WITH INPUT ARGUMENTS
      REAL FUNCTION POWER(BASE, EXP)
      REAL BASE
      INTEGER EXP
      POWER = BASE ** EXP
      RETURN
      END
\end{verbatim}
\textbf{Note}: Functions should not modify input arguments

\subsubsection*{Subroutine Argument Handling}
\begin{verbatim}
C     SUBROUTINE MODIFYING ARGUMENTS
      SUBROUTINE PROCESS(X, Y, Z)
      REAL X, Y, Z
      X = X * 2
      Y = Y / 2
      Z = X + Y
      RETURN
      END
\end{verbatim}
\textbf{Note}: Subroutines frequently modify arguments

\subsection*{6. When to Use Each}
\begin{itemize}
\item \textbf{Use Functions When}:
  - Need to return a single value
  - Performing mathematical calculations
  - Want to use result in expressions
  - Example: \texttt{AREA = CIRCLE\_AREA(R)}

\item \textbf{Use Subroutines When}:
  - Need to return multiple values
  - Modifying existing variables
  - Performing I/O operations
  - Example: \texttt{CALL SORT(ARRAY, N)}
\end{itemize}

\subsection*{7. Advanced Differences}
\subsubsection*{Memory Management}
\begin{itemize}
\item Functions: Generally use temporary storage
\item Subroutines: Often work directly on arguments
\end{itemize}

\subsubsection*{Error Handling}
\begin{verbatim}
C     SUBROUTINE WITH ERROR FLAG
      SUBROUTINE DIVIDE(A, B, RES, ERROR)
      REAL A, B, RES
      LOGICAL ERROR
      ERROR = .FALSE.
      IF (B .EQ. 0.0) THEN
          ERROR = .TRUE.
          RETURN
      END IF
      RES = A / B
      RETURN
      END
\end{verbatim}

\subsection*{8. Common Mistakes}
\subsubsection*{Function Modifying Arguments}
\begin{verbatim}
C     DANGEROUS FUNCTION
      REAL FUNCTION BADFUNC(X)
      REAL X
      X = X * 2  ! Modifying input argument
      BADFUNC = X
      RETURN
      END
\end{verbatim}
\textbf{Risk}: Unintended side effects

\subsubsection*{Using Subroutine as Function}
\begin{verbatim}
C     INCORRECT USAGE
      PROGRAM ERR
      REAL RES
      RES = SUBR()  ! Can't assign subroutine
      STOP
      END

      SUBROUTINE SUBR()
      ...
      END
\end{verbatim}

\subsection*{9. Best Practices}
\begin{itemize}
\item Use functions for pure calculations
\item Use subroutines for I/O and multi-value returns
\item Always declare function types explicitly
\item Document argument intent:
  \begin{verbatim}
  C     INPUT: X, OUTPUT: Y, INPUT/OUTPUT: Z
  \end{verbatim}
\item Avoid global variables in functions
\end{itemize}

\subsection*{10. Hybrid Example}
\begin{verbatim}
C     FUNCTION USING SUBROUTINE
      REAL FUNCTION SMART\_CALC(A, B)
      REAL A, B
      CALL PREPROCESS(A, B)
      SMART\_CALC = A ** 2 + B ** 2
      RETURN
      END

      SUBROUTINE PREPROCESS(X, Y)
      REAL X, Y
      X = ABS(X)
      Y = ABS(Y)
      RETURN
      END
\end{verbatim}

\subsection*{11. Performance Considerations}
\begin{itemize}
\item Functions better for inlining small calculations
\item Subroutines better for complex operations
\item Argument passing overhead similar for both
\item Use subroutines for memory-intensive operations
\end{itemize}
\section{Functions and Arrays in Fortran 77}

\subsection*{1. Passing Arrays to Functions}
Fortran 77 allows arrays to be passed to functions and subroutines. Key considerations:
\begin{itemize}
\item Arrays are passed by reference (modifications affect the original)
\item Size must be declared explicitly or passed as an argument
\item Use adjustable arrays with \texttt{DIMENSION} or size parameters
\end{itemize}

\subsubsection*{Example 1: Sum of Array Elements (Function)}
\begin{verbatim}
C     FUNCTION TO CALCULATE ARRAY SUM
      REAL FUNCTION ARRAY_SUM(ARR, N)
      INTEGER N
      REAL ARR(N)
      INTEGER I
      ARRAY_SUM = 0.0
      DO 10 I = 1, N
          ARRAY_SUM = ARRAY_SUM + ARR(I)
10    CONTINUE
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      PARAMETER (SIZE = 5)
      REAL NUMBERS(SIZE), ARRAY_SUM
      DATA NUMBERS /1.0, 2.0, 3.0, 4.0, 5.0/
      WRITE(*,*) 'SUM:', ARRAY_SUM(NUMBERS, SIZE)
      STOP
      END
\end{verbatim}

\subsection*{2. Multi-Dimensional Arrays}
\subsubsection*{Example 2: Matrix Trace (Function)}
\begin{verbatim}
C     FUNCTION TO CALCULATE MATRIX TRACE
      REAL FUNCTION TRACE(MAT, N)
      INTEGER N
      REAL MAT(N,N)
      INTEGER I
      TRACE = 0.0
      DO 20 I = 1, N
          TRACE = TRACE + MAT(I,I)
20    CONTINUE
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      PARAMETER (N = 3)
      REAL MATRIX(N,N), TRACE
      DATA MATRIX /1.0, 2.0, 3.0,
     *             4.0, 5.0, 6.0,
     *             7.0, 8.0, 9.0/
      WRITE(*,*) 'TRACE:', TRACE(MATRIX, N)
      STOP
      END
\end{verbatim}

\subsection*{3. Returning Arrays via Subroutines}
While functions cannot return arrays directly, subroutines can modify array arguments:
\begin{verbatim}
C     SUBROUTINE TO DOUBLE ARRAY ELEMENTS
      SUBROUTINE DOUBLE_ARRAY(ARR, N)
      INTEGER N
      REAL ARR(N)
      INTEGER I
      DO 30 I = 1, N
          ARR(I) = ARR(I) * 2.0
30    CONTINUE
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      PARAMETER (SIZE = 4)
      REAL DATA(SIZE)
      DATA DATA /1.0, 2.0, 3.0, 4.0/
      CALL DOUBLE_ARRAY(DATA, SIZE)
      WRITE(*,*) 'DOUBLED ARRAY:', DATA
      STOP
      END
\end{verbatim}

\subsection*{4. Adjustable Arrays}
Use \texttt{DIMENSION} for flexible array handling in subprograms:
\begin{verbatim}
C     FUNCTION TO FIND MAXIMUM VALUE
      REAL FUNCTION ARRAY_MAX(ARR, N)
      INTEGER N
      REAL ARR(N)
      DIMENSION ARR(N)
      INTEGER I
      ARRAY_MAX = ARR(1)
      DO 40 I = 2, N
          IF (ARR(I) .GT. ARRAY_MAX) THEN
              ARRAY_MAX = ARR(I)
          END IF
40    CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{5. Common Operations}
\subsubsection*{Example 3: Dot Product (Function)}
\begin{verbatim}
C     FUNCTION TO CALCULATE DOT PRODUCT
      REAL FUNCTION DOT_PROD(A, B, N)
      INTEGER N
      REAL A(N), B(N)
      INTEGER I
      DOT_PROD = 0.0
      DO 50 I = 1, N
          DOT_PROD = DOT_PROD + A(I) * B(I)
50    CONTINUE
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      PARAMETER (LEN = 3)
      REAL V1(LEN), V2(LEN), DOT_PROD
      DATA V1 /1.0, 2.0, 3.0/
      DATA V2 /4.0, 5.0, 6.0/
      WRITE(*,*) 'DOT PRODUCT:', DOT_PROD(V1, V2, LEN)
      STOP
      END
\end{verbatim}

\subsection*{6. Best Practices}
\begin{itemize}
\item \textbf{Always Pass Array Size}:
\begin{verbatim}
SUBROUTINE PROCESS(ARR, N)
INTEGER N
REAL ARR(N)
\end{verbatim}

\item \textbf{Use PARAMETER Constants}:
\begin{verbatim}
PARAMETER (MAX_SIZE = 100)
REAL ARR(MAX_SIZE)
\end{verbatim}

\item \textbf{Avoid Side Effects in Functions}:
\begin{verbatim}
C GOOD: Pure function
REAL FUNCTION SUM(ARR, N)
C BAD: Function modifying input
REAL FUNCTION BAD(ARR, N)
ARR(1) = 0.0
\end{verbatim}

\item \textbf{Document Array Dimensions}:
\begin{verbatim}
C     INPUT: ARR(N) - 1D array of N elements
C     OUTPUT: Returns sum of elements
\end{verbatim}
\end{itemize}

\subsection*{7. Common Errors}
\subsubsection*{Mismatched Dimensions}
\begin{verbatim}
C MAIN PROGRAM
REAL MAT(3,3)
C FUNCTION EXPECTS 1D ARRAY
CALL PRINT_ARRAY(MAT)  ! ERROR
\end{verbatim}

\subsubsection*{Incorrect Bounds}
\begin{verbatim}
DO 60 I = 1, N+1  ! N is array size
    ARR(I) = 0.0  ! OUT OF BOUNDS
60 CONTINUE
\end{verbatim}

\subsection*{8. Advanced Example: Matrix Multiplication}
\begin{verbatim}
C     SUBROUTINE FOR MATRIX MULTIPLICATION
      SUBROUTINE MAT_MUL(A, B, C, N)
      INTEGER N
      REAL A(N,N), B(N,N), C(N,N)
      INTEGER I, J, K
      DO 70 I = 1, N
          DO 80 J = 1, N
              C(I,J) = 0.0
              DO 90 K = 1, N
                  C(I,J) = C(I,J) + A(I,K) * B(K,J)
90            CONTINUE
80        CONTINUE
70    CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{9. Handling Character Arrays}
\begin{verbatim}
C     SUBROUTINE TO REVERSE STRING
      SUBROUTINE REVERSE_STR(STR, LEN)
      INTEGER LEN
      CHARACTER*(*) STR
      CHARACTER TEMP
      INTEGER I
      DO 100 I = 1, LEN/2
          TEMP = STR(I:I)
          STR(I:I) = STR(LEN-I+1:LEN-I+1)
          STR(LEN-I+1:LEN-I+1) = TEMP
100   CONTINUE
      RETURN
      END
\end{verbatim}

\section{Functions Calling Functions in Fortran 77}

\subsection*{1. Basic Function Composition}
Fortran 77 allows functions to call other functions, but with important constraints:
\begin{itemize}
\item Functions must be declared in the calling program unit
\item No direct support for recursion (without compiler extensions)
\item Functions can be nested up to compiler-dependent limits
\item Proper type declarations are critical
\end{itemize}

\subsubsection*{Example 1: Simple Function Composition}
\begin{verbatim}
C     FUNCTION TO CALCULATE SQUARE
      REAL FUNCTION SQUARE(X)
      REAL X
      SQUARE = X * X
      RETURN
      END

C     FUNCTION TO CALCULATE HYPOTENUSE
      REAL FUNCTION HYPOT(A, B)
      REAL A, B, SQUARE
      HYPOT = SQRT(SQUARE(A) + SQUARE(B))
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL HYPOT
      WRITE(*,*) 'HYPOTENUSE:', HYPOT(3.0, 4.0)
      STOP
      END
\end{verbatim}
\textbf{Explanation:}
- \texttt{HYPOT} calls \texttt{SQUARE} twice
- \texttt{SQRT} is an intrinsic function
- All functions must be declared in calling scope

\subsection*{2. Passing Functions as Arguments}
Fortran 77 supports function arguments using the \texttt{EXTERNAL} keyword:
\begin{verbatim}
C     FUNCTION INTEGRATOR
      REAL FUNCTION INTEGRAL(FUNC, A, B, N)
      EXTERNAL FUNC
      REAL FUNC, A, B
      INTEGER N
      REAL DX, X, SUM
      DX = (B - A)/N
      SUM = 0.0
      DO 10 I = 1, N
          X = A + (I-0.5)*DX
          SUM = SUM + FUNC(X)
10    CONTINUE
      INTEGRAL = SUM * DX
      RETURN
      END

C     FUNCTION TO INTEGRATE
      REAL FUNCTION POLY(X)
      REAL X
      POLY = X**3 + 2*X + 5
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      EXTERNAL POLY
      REAL INTEGRAL, RESULT
      RESULT = INTEGRAL(POLY, 0.0, 2.0, 1000)
      WRITE(*,*) 'INTEGRAL:', RESULT
      STOP
      END
\end{verbatim}

\subsection*{3. Recursion Limitations}
Standard Fortran 77 does not support recursion. Some compilers allow it with flags:
\begin{verbatim}
C     COMPILER-DEPENDENT RECURSION (GNU)
      RECURSIVE INTEGER FUNCTION FACT(N) RESULT(RES)
      INTEGER N
      IF (N <= 1) THEN
          RES = 1
      ELSE
          RES = N * FACT(N-1)
      END IF
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      WRITE(*,*) '5! =', FACT(5)
      STOP
      END
\end{verbatim}
\textbf{Note:} Not standard Fortran 77! Requires compiler extensions.

\subsection*{4. Function Libraries}
Organize related functions in separate files:
\begin{verbatim}
C     MATH_FUNCS.F
      REAL FUNCTION MEAN(ARR, N)
      REAL ARR(N)
      INTEGER N
      MEAN = SUM(ARR) / N
      END

      REAL FUNCTION STDDEV(ARR, N)
      REAL ARR(N), MEAN
      STDDEV = SQRT(SUM((ARR - MEAN(ARR,N))**2)/(N-1))
      END
\end{verbatim}

\subsection*{5. Common Patterns}
\subsubsection*{Wrapper Functions}
\begin{verbatim}
C     WRAPPER FOR DIFFERENT PRECISION
      DOUBLE PRECISION FUNCTION DEXP(X)
      DOUBLE PRECISION X
      DEXP = EXP(REAL(X))  ! Calls intrinsic EXP
      RETURN
      END
\end{verbatim}

\subsubsection*{Callback Systems}
\begin{verbatim}
C     ROOT FINDING USING CALLBACK
      REAL FUNCTION FIND_ROOT(FUNC, GUESS)
      EXTERNAL FUNC
      REAL FUNC, GUESS
      REAL X, F_X, DX
      X = GUESS
      DX = 0.001
      DO 20 I = 1, 1000
          F_X = FUNC(X)
          IF (ABS(F_X) < 1E-6) EXIT
          X = X - F_X/((FUNC(X+DX)-F_X)/DX)
20    CONTINUE
      FIND_ROOT = X
      RETURN
      END
\end{verbatim}

\subsection*{6. Best Practices}
\begin{itemize}
\item Declare all functions with \texttt{EXTERNAL} when passing as arguments
\item Use explicit interfaces for complex interactions
\item Avoid deep nesting (max 2-3 levels)
\item Document function dependencies
\item Test compiler compatibility for advanced features
\end{itemize}

\subsection*{7. Common Errors}
\subsubsection*{Missing EXTERNAL Declaration}
\begin{verbatim}
PROGRAM MAIN
REAL RESULT
RESULT = INTEGRAL(POLY, 0, 2, 100)  ! Undefined POLY
STOP
END
\end{verbatim}

\subsubsection*{Type Mismatch}
\begin{verbatim}
REAL FUNCTION F(X)
INTEGER X  ! Should be REAL
F = X**2
END
\end{verbatim}

\subsection*{8. Performance Considerations}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Technique} & \textbf{Impact} \\ 
\hline
Function inlining & Faster execution \\
Deep nesting & Increased stack usage \\
Function pointers & Slower dispatch \\
Recursion & Memory intensive \\
\hline
\end{tabular}
\end{center}

\subsection*{9. Advanced Example: Function Factory}
\begin{verbatim}
C     CREATE POWER FUNCTIONS DYNAMICALLY
      FUNCTION POWER_GEN(EXPONENT)
      REAL POWER_GEN
      REAL EXPONENT
      EXTERNAL POWER_FUNC
      POWER_GEN = POWER_FUNC
      RETURN
      END

      REAL FUNCTION POWER_FUNC(X, EXPONENT)
      REAL X, EXPONENT
      POWER_FUNC = X ** EXPONENT
      RETURN
      END

C     MAIN PROGRAM (PSEUDO-CODE)
      PROGRAM MAIN
      EXTERNAL POWER_GEN
      REAL SQUARE, CUBE
      SQUARE = POWER_GEN(2.0)
      CUBE = POWER_GEN(3.0)
      WRITE(*,*) SQUARE(5.0), CUBE(5.0)
      STOP
      END
\end{verbatim}
\textbf{Note:} Requires advanced techniques beyond standard Fortran 77.

\subsection*{10. Compiler Compatibility Table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Feature} & \textbf{gfortran} & \textbf{Intel Fortran} \\ 
\hline
Recursion & -frecursive & /recursive \\
Function pointers & Supported & Supported \\
Nested functions & No & No \\
\hline
\end{tabular}
\end{center}

\section{Function Examples in Fortran 77}

\subsection*{1. Basic Function with Return Value}
\begin{verbatim}
C     FUNCTION TO CALCULATE SQUARE
      REAL FUNCTION SQUARE(X)
      REAL X
      SQUARE = X * X
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL SQUARE
      WRITE(*,*) 'Square of 5.0:', SQUARE(5.0)
      STOP
      END
\end{verbatim}
\textbf{Explanation:} Simple function demonstrating return value and type declaration.

\subsection*{2. Integer Function with Multiple Parameters}
\begin{verbatim}
C     CALCULATE AVERAGE OF TWO INTEGERS
      INTEGER FUNCTION IAVG(A, B)
      INTEGER A, B
      IAVG = (A + B) / 2
      RETURN
      END

      PROGRAM MAIN
      INTEGER IAVG
      WRITE(*,*) 'Average(7,9):', IAVG(7,9)
      STOP
      END
\end{verbatim}

\subsection*{3. Logical Function for Prime Check}
\begin{verbatim}
C     CHECK PRIME NUMBER
      LOGICAL FUNCTION ISPRIME(N)
      INTEGER N, I
      ISPRIME = .TRUE.
      DO 10 I = 2, INT(SQRT(REAL(N)))
          IF (MOD(N,I) .EQ. 0) THEN
              ISPRIME = .FALSE.
              RETURN
          END IF
10    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      LOGICAL ISPRIME
      WRITE(*,*) '17 is prime:', ISPRIME(17)
      STOP
      END
\end{verbatim}

\subsection*{4. Character Function}
\begin{verbatim}
C     RETURN GRADE LETTER
      CHARACTER*1 FUNCTION GRADE(SCORE)
      REAL SCORE
      IF (SCORE .GE. 90.0) THEN
          GRADE = 'A'
      ELSE IF (SCORE .GE. 80.0) THEN
          GRADE = 'B'
      ELSE
          GRADE = 'F'
      END IF
      RETURN
      END

      PROGRAM MAIN
      CHARACTER*1 GRADE
      WRITE(*,*) 'Grade(85): ', GRADE(85.0)
      STOP
      END
\end{verbatim}

\subsection*{5. Array Sum Function}
\begin{verbatim}
C     SUM ARRAY ELEMENTS
      REAL FUNCTION ARRSUM(ARR, N)
      INTEGER N
      REAL ARR(N)
      INTEGER I
      ARRSUM = 0.0
      DO 20 I = 1, N
          ARRSUM = ARRSUM + ARR(I)
20    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL ARR(5), ARRSUM
      DATA ARR /1.0,2.0,3.0,4.0,5.0/
      WRITE(*,*) 'Array sum:', ARRSUM(ARR,5)
      STOP
      END
\end{verbatim}

\subsection*{6. Matrix Trace Function}
\begin{verbatim}
C     CALCULATE MATRIX TRACE
      REAL FUNCTION TRACE(MAT, N)
      INTEGER N
      REAL MAT(N,N)
      INTEGER I
      TRACE = 0.0
      DO 30 I = 1, N
          TRACE = TRACE + MAT(I,I)
30    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL MAT(3,3), TRACE
      DATA MAT /1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0/
      WRITE(*,*) 'Trace:', TRACE(MAT,3)
      STOP
      END
\end{verbatim}

\subsection*{7. Function with Multiple Returns}
\begin{verbatim}
C     CALCULATE BOTH SUM AND DIFFERENCE
      SUBROUTINE SUMDIFF(A, B, SUM, DIFF)
      REAL A, B, SUM, DIFF
      SUM = A + B
      DIFF = A - B
      RETURN
      END

      PROGRAM MAIN
      REAL S, D
      CALL SUMDIFF(8.0, 5.0, S, D)
      WRITE(*,*) 'Sum:', S, 'Diff:', D
      STOP
      END
\end{verbatim}

\subsection*{8. Recursive Factorial (Compiler-dependent)}
\begin{verbatim}
C     RECURSIVE FACTORIAL (NON-STANDARD)
      INTEGER FUNCTION FACT(N)
      INTEGER N
      IF (N .LE. 1) THEN
          FACT = 1
      ELSE
          FACT = N * FACT(N-1)
      END IF
      RETURN
      END

      PROGRAM MAIN
      INTEGER FACT
      WRITE(*,*) '5! =', FACT(5)
      STOP
      END
\end{verbatim}
\textbf{Note:} Requires compiler support for recursion.

\subsection*{9. Function with Array Modification}
\begin{verbatim}
C     DOUBLE ARRAY ELEMENTS
      SUBROUTINE DOUBLEARR(ARR, N)
      INTEGER N, I
      REAL ARR(N)
      DO 40 I = 1, N
          ARR(I) = ARR(I) * 2.0
40    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL NUM(3)
      DATA NUM /1.0,2.0,3.0/
      CALL DOUBLEARR(NUM,3)
      WRITE(*,*) 'Doubled:', NUM
      STOP
      END
\end{verbatim}

\subsection*{10. Function as Argument}
\begin{verbatim}
C     NUMERICAL INTEGRATION
      REAL FUNCTION INTEGRAL(FUNC, A, B, N)
      EXTERNAL FUNC
      REAL FUNC, A, B, DX, X, SUM
      INTEGER N, I
      DX = (B - A)/N
      SUM = 0.0
      DO 50 I = 1, N
          X = A + (I-0.5)*DX
          SUM = SUM + FUNC(X)
50    CONTINUE
      INTEGRAL = SUM * DX
      RETURN
      END

      REAL FUNCTION SQUARE(X)
      REAL X
      SQUARE = X**2
      RETURN
      END

      PROGRAM MAIN
      EXTERNAL SQUARE
      REAL INTEGRAL
      WRITE(*,*) 'Integral:', INTEGRAL(SQUARE,0.0,2.0,1000)
      STOP
      END
\end{verbatim}

\subsection*{11. Error Handling in Function}
\begin{verbatim}
C     SAFE DIVISION FUNCTION
      REAL FUNCTION SAFEDIV(A, B, ERROR)
      REAL A, B
      LOGICAL ERROR
      ERROR = .FALSE.
      IF (B .EQ. 0.0) THEN
          ERROR = .TRUE.
          SAFEDIV = 0.0
      ELSE
          SAFEDIV = A / B
      END IF
      RETURN
      END

      PROGRAM MAIN
      REAL SAFEDIV
      LOGICAL ERR
      WRITE(*,*) '10/0 =', SAFEDIV(10.0,0.0,ERR), 'Error:', ERR
      STOP
      END
\end{verbatim}

\subsection*{12. String Manipulation Function}
\begin{verbatim}
C     REVERSE STRING
      SUBROUTINE REVSTR(STR, LEN)
      INTEGER LEN, I
      CHARACTER STR*(*), TEMP
      DO 60 I = 1, LEN/2
          TEMP = STR(I:I)
          STR(I:I) = STR(LEN-I+1:LEN-I+1)
          STR(LEN-I+1:LEN-I+1) = TEMP
60    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      CHARACTER*10 S
      S = 'HELLO'
      CALL REVSTR(S,5)
      WRITE(*,*) 'Reversed:', S
      STOP
      END
\end{verbatim}

\subsection*{13. Multi-dimensional Array Function}
\begin{verbatim}
C     MATRIX MULTIPLICATION
      SUBROUTINE MATMUL(A,B,C,N)
      INTEGER N,I,J,K
      REAL A(N,N), B(N,N), C(N,N)
      DO 70 I=1,N
      DO 70 J=1,N
          C(I,J)=0.0
          DO 70 K=1,N
70            C(I,J)=C(I,J)+A(I,K)*B(K,J)
      RETURN
      END

      PROGRAM MAIN
      REAL A(2,2),B(2,2),C(2,2)
      DATA A/1.0,2.0,3.0,4.0/, B/5.0,6.0,7.0,8.0/
      CALL MATMUL(A,B,C,2)
      WRITE(*,*) 'Product:', C
      STOP
      END
\end{verbatim}

\subsection*{14. Function with Variable Arguments}
\begin{verbatim}
C     CALCULATE MEAN OF VARIABLE ARGUMENTS
      REAL FUNCTION MEAN(N, ...)
C     WARNING: NOT STANDARD FORTRAN 77
C     (Requires compiler-specific implementation)
      INTEGER N,I
      REAL SUM,X
      SUM = 0.0
      DO 80 I = 1, N
          X = VARARG(I)  ! Pseudo-code
          SUM = SUM + X
80    CONTINUE
      MEAN = SUM/N
      RETURN
      END
\end{verbatim}
\textbf{Note:} Demonstrates conceptual variable arguments.

\subsection*{15. Function Returning Array}
\begin{verbatim}
C     RETURN ARRAY OF SQUARES
      SUBROUTINE SQUARES(ARR, N)
      INTEGER N, I
      REAL ARR(N)
      DO 90 I = 1, N
          ARR(I) = REAL(I)**2
90    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL NUM(5)
      CALL SQUARES(NUM,5)
      WRITE(*,*) 'Squares:', NUM
      STOP
      END
\end{verbatim}

\subsection*{16. Type Conversion Function}
\begin{verbatim}
C     FAHRENHEIT TO CELSIUS
      REAL FUNCTION F2C(F)
      REAL F
      F2C = (F - 32.0) * 5.0/9.0
      RETURN
      END

      PROGRAM MAIN
      REAL F2C
      WRITE(*,*) '32F =', F2C(32.0), 'C'
      STOP
      END
\end{verbatim}

\subsection*{17. Function with COMMON Block}
\begin{verbatim}
C     GLOBAL CONSTANT USING COMMON
      REAL FUNCTION CIRCUM(R)
      REAL R, PI
      COMMON /CONST/ PI
      CIRCUM = 2.0 * PI * R
      RETURN
      END

      PROGRAM MAIN
      REAL CIRCUM, PI
      COMMON /CONST/ PI
      PI = 3.14159
      WRITE(*,*) 'Circumference:', CIRCUM(1.0)
      STOP
      END
\end{verbatim}

\subsection*{18. Function with SAVE Attribute}
\begin{verbatim}
C     COUNTER WITH PERSISTENT STATE
      INTEGER FUNCTION COUNTER()
      INTEGER COUNT
      SAVE COUNT
      DATA COUNT /0/
      COUNT = COUNT + 1
      COUNTER = COUNT
      RETURN
      END

      PROGRAM MAIN
      WRITE(*,*) 'Count:', COUNTER(), COUNTER(), COUNTER()
      STOP
      END
\end{verbatim}

\subsection*{19. Bitwise Operations Function}
\begin{verbatim}
C     BITWISE AND FUNCTION
      INTEGER FUNCTION BITAND(A, B)
      INTEGER A, B
      BITAND = AND(A, B)
      RETURN
      END

      PROGRAM MAIN
      INTEGER BITAND
      WRITE(*,*) '5 & 3 =', BITAND(5,3)
      STOP
      END
\end{verbatim}

\subsection*{20. Complex Number Function}
\begin{verbatim}
C     COMPLEX NUMBER ADDITION
      COMPLEX FUNCTION CADD(A, B)
      COMPLEX A, B
      CADD = A + B
      RETURN
      END

      PROGRAM MAIN
      COMPLEX C1, C2, C3, CADD
      C1 = (1.0, 2.0)
      C2 = (3.0, 4.0)
      C3 = CADD(C1, C2)
      WRITE(*,*) 'Sum:', C3
      STOP
      END
\end{verbatim}

\section{Exercises: Functions in Fortran 77}

\subsection{Basic Function Implementation}
1. **Area of Circle**:  
Write a real function `CIRCLE_AREA(R)` that calculates the area of a circle.  
Sample: Input=3.0 â†’ Outputâ‰ˆ28.2743  

2. **Factorial Function**:  
Create an integer function `FACT(N)` to compute factorial (iterative approach).  
Sample: Input=5 â†’ Output=120  

3. **Even/Odd Check**:  
Implement a logical function `ISEVEN(NUM)` returning `.TRUE.` for even integers.  
Sample: Input=7 â†’ Output=.FALSE.  

4. **Grade Converter**:  
Write a character function `GRADE(SCORE)` returning 'A'-'F' based on score (90-100: 'A', etc.).  

\subsection*{Array \& Matrix Functions}  
5. **Array Sum**:  
Create a real function `ARRAY_SUM(ARR, N)` to sum elements of a 1D array.  

6. **Matrix Trace**:  
Implement a real function `TRACE(MAT, N)` to calculate the trace of an NÃ—N matrix.  

7. **Maximum Element**:  
Write a function `ARRAY_MAX(ARR, N)` returning the largest value in a 1D array.  

8. **Matrix Symmetry Check**:  
Develop a logical function `IS_SYMMETRIC(MAT, N)` to check if a matrix is symmetric.  

\subsection*{String \& Character Functions}  
9. **String Reversal**:  
Create a subroutine `REVERSE_STR(STR, LEN)` to reverse a character string.  

10. **Vowel Counter**:  
Implement an integer function `COUNT_VOWELS(STR)` returning the number of vowels (A/E/I/O/U).  

11. **Palindrome Check**:  
Write a logical function `IS_PALINDROME(STR)` to check if a string reads the same backward.  

\subsection*{Mathematical Functions}  
12. **Prime Check**:  
Develop a logical function `IS_PRIME(N)` to test primality of an integer.  

13. **Temperature Conversion**:  
Create a real function `F2C(F)` converting Fahrenheit to Celsius.  

14. **Dot Product**:  
Implement a real function `DOT_PROD(VEC1, VEC2, N)` for two N-element vectors.  

15. **Standard Deviation**:  
Write a function `STD_DEV(ARR, N)` to calculate standard deviation of an array.  

\subsection*{Advanced Function Concepts}  
16. **Common Block Function**:  
Create a function `CIRCUMFERENCE(R)` using a COMMON block to store Ï€ (3.14159).  

17. **Persistent Counter**:  
Implement an integer function `COUNTER()` with SAVE attribute to increment on each call.  

18. **Function Argument**:  
Write an integration function `INTEGRATE(FUNC, A, B, N)` accepting another function as argument.  

19. **Bitwise Operations**:  
Create integer functions for:  
a) `BITWISE_AND(A, B)`  
b) `BITWISE_OR(A, B)`  

20. **Complex Numbers**:  
Implement a complex function `C_ADD(A, B)` to add two complex numbers.  

\subsection*{Error Handling \& Validation}  
21. **Safe Division**:  
Create a function `SAFE_DIV(A, B, ERROR)` that sets ERROR flag for division by zero.  

22. **Input Validator**:  
Write a logical function `VALID_INPUT(STR)` checking if a string contains only digits.  

\subsection*{Challenge Problems}  
23. **Matrix Multiplier**:  
Develop a subroutine `MAT_MUL(A, B, C, N)` multiplying two NÃ—N matrices.  

24. **Function Composition**:  
Implement `FOG(X) = F(G(X))` where F(X)=xÂ² and G(X)=x+1 as separate functions.  

25. **Statistical Suite**:  
Create a set of functions:  
- `MEAN(ARR, N)`  
- `MEDIAN(ARR, N)`  
- `MODE(ARR, N)`  

\section{Exercise Answers: Functions in Fortran 77}

\subsection*{1. Area of Circle}
\begin{verbatim}
C     CALCULATE AREA OF CIRCLE
      REAL FUNCTION CIRCLE_AREA(R)
      REAL R, PI
      PARAMETER (PI = 3.14159)
      CIRCLE_AREA = PI * R**2
      RETURN
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      REAL CIRCLE_AREA
      WRITE(*,*) 'Area:', CIRCLE_AREA(3.0)
      STOP
      END
\end{verbatim}
\textbf{Explanation:} Uses Ï€ constant and square calculation. Returns real value.

\subsection*{2. Factorial Function}
\begin{verbatim}
C     ITERATIVE FACTORIAL
      INTEGER FUNCTION FACT(N)
      INTEGER N, I
      FACT = 1
      DO 10 I = 1, N
          FACT = FACT * I
10    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      INTEGER FACT
      WRITE(*,*) '5! =', FACT(5)
      STOP
      END
\end{verbatim}
\textbf{Note:} Initializes result to 1 and multiplies sequentially.

\subsection*{3. Even/Odd Check}
\begin{verbatim}
C     EVEN NUMBER CHECK
      LOGICAL FUNCTION ISEVEN(NUM)
      INTEGER NUM
      ISEVEN = MOD(NUM, 2) .EQ. 0
      RETURN
      END

      PROGRAM MAIN
      LOGICAL ISEVEN
      WRITE(*,*) '7 is even?', ISEVEN(7)
      STOP
      END
\end{verbatim}
\textbf{Logic:} Uses modulus operator for even check.

\subsection*{4. Grade Converter}
\begin{verbatim}
C     GRADE CONVERSION
      CHARACTER*1 FUNCTION GRADE(SCORE)
      REAL SCORE
      IF (SCORE .GE. 90.0) THEN
          GRADE = 'A'
      ELSE IF (SCORE .GE. 80.0) THEN
          GRADE = 'B'
      ELSE IF (SCORE .GE. 70.0) THEN
          GRADE = 'C'
      ELSE
          GRADE = 'F'
      END IF
      RETURN
      END

      PROGRAM MAIN
      CHARACTER*1 GRADE
      WRITE(*,*) 'Grade 85:', GRADE(85.0)
      STOP
      END
\end{verbatim}

\subsection*{5. Array Sum}
\begin{verbatim}
C     SUM ARRAY ELEMENTS
      REAL FUNCTION ARRAY_SUM(ARR, N)
      INTEGER N
      REAL ARR(N)
      INTEGER I
      ARRAY_SUM = 0.0
      DO 20 I = 1, N
          ARRAY_SUM = ARRAY_SUM + ARR(I)
20    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL ARR(5), ARRAY_SUM
      DATA ARR /1.0,2.0,3.0,4.0,5.0/
      WRITE(*,*) 'Sum:', ARRAY_SUM(ARR,5)
      STOP
      END
\end{verbatim}

\subsection*{6. Matrix Trace}
\begin{verbatim}
C     MATRIX TRACE CALCULATION
      REAL FUNCTION TRACE(MAT, N)
      INTEGER N
      REAL MAT(N,N)
      INTEGER I
      TRACE = 0.0
      DO 30 I = 1, N
          TRACE = TRACE + MAT(I,I)
30    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL MAT(3,3), TRACE
      DATA MAT /1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0/
      WRITE(*,*) 'Trace:', TRACE(MAT,3)
      STOP
      END
\end{verbatim}

\subsection*{7. Maximum Element}
\begin{verbatim}
C     FIND ARRAY MAXIMUM
      REAL FUNCTION ARRAY_MAX(ARR, N)
      INTEGER N
      REAL ARR(N)
      INTEGER I
      ARRAY_MAX = ARR(1)
      DO 40 I = 2, N
          IF (ARR(I) .GT. ARRAY_MAX) THEN
              ARRAY_MAX = ARR(I)
          END IF
40    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      REAL ARR(5), ARRAY_MAX
      DATA ARR /3.0,1.0,4.0,1.0,5.0/
      WRITE(*,*) 'Max:', ARRAY_MAX(ARR,5)
      STOP
      END
\end{verbatim}

\subsection*{8. Matrix Symmetry Check}
\begin{verbatim}
C     CHECK MATRIX SYMMETRY
      LOGICAL FUNCTION IS_SYMMETRIC(MAT, N)
      INTEGER N
      REAL MAT(N,N)
      INTEGER I, J
      IS_SYMMETRIC = .TRUE.
      DO 50 I = 1, N
          DO 60 J = I+1, N
              IF (MAT(I,J) .NE. MAT(J,I)) THEN
                  IS_SYMMETRIC = .FALSE.
                  RETURN
              END IF
60        CONTINUE
50    CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{9. String Reversal}
\begin{verbatim}
C     REVERSE STRING
      SUBROUTINE REVERSE_STR(STR, LEN)
      INTEGER LEN, I
      CHARACTER STR*(*), TEMP
      DO 70 I = 1, LEN/2
          TEMP = STR(I:I)
          STR(I:I) = STR(LEN-I+1:LEN-I+1)
          STR(LEN-I+1:LEN-I+1) = TEMP
70    CONTINUE
      RETURN
      END

      PROGRAM MAIN
      CHARACTER*5 S
      S = 'HELLO'
      CALL REVERSE_STR(S,5)
      WRITE(*,*) 'Reversed:', S
      STOP
      END
\end{verbatim}

\subsection*{10. Vowel Counter}
\begin{verbatim}
C     COUNT VOWELS
      INTEGER FUNCTION COUNT_VOWELS(STR)
      CHARACTER*(*) STR
      INTEGER I, LEN
      COUNT_VOWELS = 0
      LEN = LEN_TRIM(STR)
      DO 80 I = 1, LEN
          IF (INDEX('AEIOUaeiou', STR(I:I)) .GT. 0) THEN
              COUNT_VOWELS = COUNT_VOWELS + 1
          END IF
80    CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{11. Palindrome Check}
\begin{verbatim}
C     PALINDROME CHECK
      LOGICAL FUNCTION IS_PALINDROME(STR)
      CHARACTER*(*) STR, REV_STR
      INTEGER LEN
      LEN = LEN_TRIM(STR)
      REV_STR = STR
      CALL REVERSE_STR(REV_STR, LEN)
      IS_PALINDROME = STR(1:LEN) .EQ. REV_STR(1:LEN)
      RETURN
      END
\end{verbatim}

\subsection*{12. Prime Check}
\begin{verbatim}
C     PRIME CHECK
      LOGICAL FUNCTION IS_PRIME(N)
      INTEGER N, I
      IF (N .LE. 1) THEN
          IS_PRIME = .FALSE.
          RETURN
      END IF
      DO 90 I = 2, SQRT(REAL(N))
          IF (MOD(N,I) .EQ. 0) THEN
              IS_PRIME = .FALSE.
              RETURN
          END IF
90    CONTINUE
      IS_PRIME = .TRUE.
      RETURN
      END
\end{verbatim}

\subsection*{13. Temperature Conversion}
\begin{verbatim}
C     FAHRENHEIT TO CELSIUS
      REAL FUNCTION F2C(F)
      REAL F
      F2C = (F - 32.0) * 5.0/9.0
      RETURN
      END

      PROGRAM MAIN
      REAL F2C
      WRITE(*,*) '212F =', F2C(212.0), 'C'
      STOP
      END
\end{verbatim}

\subsection*{14. Dot Product}
\begin{verbatim}
C     DOT PRODUCT
      REAL FUNCTION DOT_PROD(VEC1, VEC2, N)
      INTEGER N
      REAL VEC1(N), VEC2(N)
      INTEGER I
      DOT_PROD = 0.0
      DO 100 I = 1, N
          DOT_PROD = DOT_PROD + VEC1(I)*VEC2(I)
100   CONTINUE
      RETURN
      END
\end{verbatim}

\subsection*{15. Standard Deviation}
\begin{verbatim}
C     STANDARD DEVIATION
      REAL FUNCTION STD_DEV(ARR, N)
      REAL ARR(N), MEAN
      INTEGER N, I
      MEAN = ARRAY_SUM(ARR,N)/REAL(N)
      STD_DEV = 0.0
      DO 110 I = 1, N
          STD_DEV = STD_DEV + (ARR(I)-MEAN)**2
110   CONTINUE
      STD_DEV = SQRT(STD_DEV/REAL(N))
      RETURN
      END
\end{verbatim}

\subsection*{16. Common Block Circumference}
\begin{verbatim}
C     CIRCUMFERENCE WITH COMMON
      REAL FUNCTION CIRCUM(R)
      REAL R, PI
      COMMON /CONST/ PI
      CIRCUM = 2.0 * PI * R
      RETURN
      END

      PROGRAM MAIN
      REAL CIRCUM, PI
      COMMON /CONST/ PI
      PI = 3.14159
      WRITE(*,*) 'Circumference:', CIRCUM(1.0)
      STOP
      END
\end{verbatim}

\subsection*{17. Persistent Counter}
\begin{verbatim}
C     PERSISTENT COUNTER
      INTEGER FUNCTION COUNTER()
      INTEGER COUNT
      SAVE COUNT
      DATA COUNT /0/
      COUNT = COUNT + 1
      COUNTER = COUNT
      RETURN
      END
\end{verbatim}

\subsection*{18. Function Argument Integration}
\begin{verbatim}
C     NUMERICAL INTEGRATION
      REAL FUNCTION INTEGRAL(FUNC, A, B, N)
      EXTERNAL FUNC
      REAL FUNC, A, B, DX, X, SUM
      INTEGER N, I
      DX = (B - A)/N
      SUM = 0.0
      DO 120 I = 1, N
          X = A + (I-0.5)*DX
          SUM = SUM + FUNC(X)
120   CONTINUE
      INTEGRAL = SUM * DX
      RETURN
      END
\end{verbatim}

\subsection*{19. Bitwise Operations}
\begin{verbatim}
C     BITWISE AND
      INTEGER FUNCTION BITWISE_AND(A, B)
      INTEGER A, B
      BITWISE_AND = AND(A, B)
      RETURN
      END

C     BITWISE OR
      INTEGER FUNCTION BITWISE_OR(A, B)
      INTEGER A, B
      BITWISE_OR = OR(A, B)
      RETURN
      END
\end{verbatim}

\subsection*{20. Complex Number Addition}
\begin{verbatim}
C     COMPLEX ADDITION
      COMPLEX FUNCTION C_ADD(A, B)
      COMPLEX A, B
      C_ADD = A + B
      RETURN
      END

      PROGRAM MAIN
      COMPLEX C1, C2, C_ADD
      C1 = (1.0, 2.0)
      C2 = (3.0, 4.0)
      WRITE(*,*) 'Sum:', C_ADD(C1, C2)
      STOP
      END
\end{verbatim}

\section{Problem Solving Methodologies}

\subsection*{Exercise 1: Area of Circle}
\subsubsection*{Problem Analysis}
Calculate the area of a circle using formula \( A = \pi r^2 \).

\subsubsection*{Solution Approach}
\begin{enumerate}
\item Create real function \texttt{CIRCLE\_AREA} accepting radius
\item Declare constant \(\pi\) using \texttt{PARAMETER}
\item Implement area formula
\item Return calculated value
\end{enumerate}

\subsubsection*{Key Concepts}
\begin{itemize}
\item Function declaration with return type
\item Constant parameters
\item Arithmetic operations
\end{itemize}

\subsection*{Exercise 2: Factorial Function}
\subsubsection*{Problem Analysis}
Compute \( n! \) iteratively.

\subsubsection*{Solution Approach}
\begin{enumerate}
\item Initialize result to 1
\item Multiply sequentially from 1 to \( n \)
\item Return accumulated product
\end{enumerate}

\subsubsection*{Important Notes}
\begin{itemize}
\item Handles \( n = 0 \) correctly
\item Uses integer type for exact results
\end{itemize}

\subsection*{Exercise 3: Even/Odd Check}
\subsubsection*{Problem Analysis}
Determine if number is even using modulus operation.

\subsubsection*{Solution Approach}
\begin{enumerate}
\item Use \texttt{MOD} function with divisor 2
\item Return \texttt{.TRUE.} if remainder is 0
\item Logical result directly from comparison
\end{enumerate}

\subsubsection*{Optimization}
\begin{itemize}
\item Single-line implementation possible
\item No explicit \texttt{IF} statement needed
\end{itemize}

\subsection*{Exercise 4: Grade Converter}
\subsubsection*{Problem Analysis}
Convert numerical score to letter grade.

\subsubsection*{Solution Strategy}
\begin{enumerate}
\item Use cascading \texttt{IF-ELSE} structure
\item Compare score against thresholds
\item Return corresponding character
\end{enumerate}

\subsubsection*{Edge Cases}
\begin{itemize}
\item Handles scores above 100 and below 0
\item Returns 'F' as default case
\end{itemize}

\subsection*{Exercise 5: Array Sum}
\subsubsection*{Implementation Logic}
\begin{enumerate}
\item Initialize sum to 0.0
\item Iterate through array elements
\item Accumulate total using loop
\end{enumerate}

\subsubsection*{Memory Considerations}
\begin{itemize}
\item Array passed by reference
\item No size limit except memory constraints
\end{itemize}

\subsection*{Exercise 6: Matrix Trace}
\subsubsection*{Algorithm Steps}
\begin{enumerate}
\item Initialize sum to 0.0
\item Iterate diagonal elements \( (i,i) \)
\item Accumulate diagonal values
\end{enumerate}

\subsubsection*{Matrix Handling}
\begin{itemize}
\item Column-major order irrelevant for trace
\item Works for any square matrix size
\end{itemize}

\subsection*{Exercise 7: Maximum Element}
\subsubsection*{Search Strategy}
\begin{enumerate}
\item Assume first element is maximum
\item Compare with subsequent elements
\item Update maximum when larger value found
\end{enumerate}

\subsubsection*{Efficiency}
\begin{itemize}
\item Single pass \( O(n) \) complexity
\item Requires \( n-1 \) comparisons
\end{itemize}

\subsection*{Exercise 8: Matrix Symmetry}
\subsubsection*{Verification Method}
\begin{enumerate}
\item Check \( mat(i,j) = mat(j,i) \forall i,j \)
\item Early exit on first mismatch
\item Upper triangular comparison
\end{enumerate}

\subsubsection*{Optimization}
\begin{itemize}
\item Avoids redundant comparisons
\item Uses \( j = i+1 \) to reduce iterations
\end{itemize}

\subsection*{Exercise 9: String Reversal}
\subsubsection*{In-Place Algorithm}
\begin{enumerate}
\item Swap characters from ends to middle
\item Use temporary character storage
\item Handle even/odd length strings
\end{enumerate}

\subsubsection*{String Handling}
\begin{itemize}
\item Fortran substring notation
\item Implicit length handling
\end{itemize}

\subsection*{Exercise 10: Vowel Counter}
\subsubsection*{Detection Method}
\begin{enumerate}
\item Check each character against vowel set
\item Use \texttt{INDEX} function for membership test
\item Case-insensitive comparison
\end{enumerate}

\subsubsection*{Efficiency Note}
\begin{itemize}
\item Linear scan \( O(n) \) complexity
\item Alternative: Use logical OR of comparisons
\end{itemize}

[Continued in similar format for remaining exercises...]

\subsection*{Exercise 20: Complex Addition}
\subsubsection*{Complex Handling}
\begin{enumerate}
\item Use Fortran complex data type
\item Leverage built-in complex arithmetic
\item Return complex result directly
\end{enumerate}

\subsubsection*{Type Safety}
\begin{itemize}
\item Implicit complex operations
\item Real and imaginary parts handled automatically
\end{itemize}

\section*{General Problem Solving Patterns}
\begin{itemize}
\item \textbf{Input Validation}: Check for valid ranges/values
\item \textbf{Edge Cases}: Handle minimum/maximum values
\item \textbf{Efficiency}: Optimize loop structures
\item \textbf{Memory}: Consider array passing mechanisms
\item \textbf{Modularity}: Decompose into sub-functions
\end{itemize}

\chapter{Recursion in Fortran 77}

\subsection*{Conceptual Overview}
Recursion is a programming technique where a function calls itself to solve smaller instances of the same problem. A recursive function typically consists of:
\begin{itemize}
\item \textbf{Base Case}: Termination condition preventing infinite loops
\item \textbf{Recursive Case}: Function calls itself with modified parameters
\end{itemize}

\subsection*{Fortran 77 Implementation Challenges}
\begin{itemize}
\item \textbf{No Official Support}: Original Fortran 77 standard prohibits recursion
\item \textbf{Compiler Extensions}: Some modern compilers (e.g., gfortran) allow recursion with flags
\item \textbf{Stack Limitations}: Deep recursion may cause stack overflows
\end{itemize}

\subsection*{Enabling Recursion in Modern Compilers}
Example compilation flags:
\begin{verbatim}
gfortran -frecursive program.f  # GNU Fortran
ifort -recursive program.f      # Intel Fortran
\end{verbatim}

\subsection*{Example 1: Factorial Calculation}
\begin{verbatim}
C     RECURSIVE FACTORIAL FUNCTION
      RECURSIVE INTEGER FUNCTION FACT(N) RESULT(RES)
      INTEGER N
      IF (N <= 0) THEN
          RES = 1
      ELSE
          RES = N * FACT(N-1)
      END IF
      END

C     MAIN PROGRAM
      PROGRAM MAIN
      INTEGER FACT
      WRITE(*,*) '5! =', FACT(5)
      STOP
      END
\end{verbatim}

\textbf{Components:}
\begin{itemize}
\item \texttt{RECURSIVE} keyword declares recursive capability
\item \texttt{RESULT} clause specifies return variable
\item Base case: \( n \leq 0 \) returns 1
\item Recursive case: \( n \times fact(n-1) \)
\end{itemize}

\subsection*{Example 2: Fibonacci Sequence}
\begin{verbatim}
C     RECURSIVE FIBONACCI
      RECURSIVE INTEGER FUNCTION FIB(N) RESULT(RES)
      INTEGER N
      IF (N <= 0) THEN
          RES = 0
      ELSE IF (N == 1) THEN
          RES = 1
      ELSE
          RES = FIB(N-1) + FIB(N-2)
      END IF
      END

      PROGRAM MAIN
      INTEGER FIB
      WRITE(*,*) 'Fib(10) =', FIB(10)
      STOP
      END
\end{verbatim}

\subsection*{Key Considerations}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Aspect} & \textbf{Details} \\ 
\hline
Stack Depth & Limited by compiler/memory settings \\
Performance & Generally slower than iteration \\
Memory Use & Grows linearly with recursion depth \\
Readability & Often clearer for mathematical problems \\
\hline
\end{tabular}
\end{center}

\subsection*{Appropriate Use Cases}
\begin{itemize}
\item Mathematical series (factorial, Fibonacci)
\item Tree traversals (in hierarchical data structures)
\item Divide-and-conquer algorithms (QuickSort)
\item Backtracking algorithms (permutations)
\end{itemize}

\subsection*{Performance Comparison: Recursive vs Iterative}
\begin{verbatim}
C     ITERATIVE FACTORIAL
      INTEGER FUNCTION ITER_FACT(N)
      INTEGER N, I
      ITER_FACT = 1
      DO 10 I = 1, N
          ITER_FACT = ITER_FACT * I
10    CONTINUE
      END
\end{verbatim}

\textbf{Advantages of Iteration:}
\begin{itemize}
\item Fixed memory usage (\( O(1) \))
\item Faster execution (no function call overhead)
\item No stack overflow risk
\end{itemize}

\subsection*{Recursion Best Practices}
\begin{enumerate}
\item Always define clear base cases
\item Limit recursion depth (<1000 levels)
\item Prefer iteration for performance-critical code
\item Use compiler warnings (-Wall -Wextra)
\item Test across different compilers
\end{enumerate}

\subsection*{Advanced Example: Binary Search}
\begin{verbatim}
C     RECURSIVE BINARY SEARCH
      RECURSIVE INTEGER FUNCTION BSEARCH(ARR, L, R, X) RESULT(INDEX)
      INTEGER ARR(*), L, R, X, MID
      IF (R >= L) THEN
          MID = L + (R - L)/2
          IF (ARR(MID) == X) THEN
              INDEX = MID
          ELSE IF (ARR(MID) > X) THEN
              INDEX = BSEARCH(ARR, L, MID-1, X)
          ELSE
              INDEX = BSEARCH(ARR, MID+1, R, X)
          END IF
      ELSE
          INDEX = -1
      END IF
      END

      PROGRAM MAIN
      INTEGER ARR(5), BSEARCH
      DATA ARR /2,4,6,8,10/
      WRITE(*,*) 'Found at:', BSEARCH(ARR,1,5,8)
      STOP
      END
\end{verbatim}

\subsection*{Limitations and Risks}
\begin{itemize}
\item \textbf{Stack Overflow}: Deep recursion may crash program
\item \textbf{Portability}: Non-standard across compilers
\item \textbf{Debugging Difficulty}: Complex call stacks
\item \textbf{Memory Efficiency}: Worse than iteration
\end{itemize}

\subsection*{Historical Context}
Original Fortran 77 restrictions stemmed from:
\begin{itemize}
\item Early computer memory limitations
\item Static memory allocation requirements
\item Focus on numerical/scientific computations
\end{itemize}

\subsection*{Modern Alternatives}
For projects requiring recursion:
\begin{itemize}
\item Use Fortran 90+ with standard recursion support
\item Implement recursive algorithms iteratively
\item Combine Fortran with recursive-friendly languages
\end{itemize}

\section{Recursive Programming Examples in Fortran 77}

\subsection*{1. Factorial Calculation}
\begin{verbatim}
RECURSIVE INTEGER FUNCTION FACT(n) RESULT(res)
INTEGER, INTENT(IN) :: n
IF (n <= 0) THEN
    res = 1
ELSE
    res = n * FACT(n-1)
END IF
END FUNCTION

! Working Principle:
! Base case: n â‰¤ 0 returns 1
! Recursive case: n * fact(n-1)
! Tree: Linear single recursion
\end{verbatim}

\subsection*{2. Fibonacci Sequence}
\begin{verbatim}
RECURSIVE INTEGER FUNCTION FIB(n) RESULT(res)
INTEGER, INTENT(IN) :: n
IF (n <= 0) THEN
    res = 0
ELSE IF (n == 1) THEN
    res = 1
ELSE
    res = FIB(n-1) + FIB(n-2)
END IF
END FUNCTION

! Working Principle:
! Binary recursion with two base cases
! Exponential time complexity O(2^n)
\end{verbatim}

\subsection*{3. Greatest Common Divisor (GCD)}
\begin{verbatim}
RECURSIVE INTEGER FUNCTION GCD(a,b) RESULT(res)
INTEGER, INTENT(IN) :: a, b
IF (b == 0) THEN
    res = a
ELSE
    res = GCD(b, MOD(a,b))
END IF
END FUNCTION

! Working Principle:
! Euclid's algorithm implementation
! Recursively applies GCD(b, a mod b)
\end{verbatim}

\subsection*{4. Array Summation}
\begin{verbatim}
RECURSIVE REAL FUNCTION ARRAY_SUM(arr, n) RESULT(res)
REAL, INTENT(IN) :: arr(n)
INTEGER, INTENT(IN) :: n
IF (n == 0) THEN
    res = 0.0
ELSE
    res = arr(n) + ARRAY_SUM(arr, n-1)
END IF
END FUNCTION

! Working Principle:
! Accumulates sum from last element backward
! Linear recursion O(n) complexity
\end{verbatim}

\subsection*{5. Binary Search}
\begin{verbatim}
RECURSIVE INTEGER FUNCTION BSEARCH(arr, l, r, x) RESULT(res)
INTEGER, INTENT(IN) :: arr(*), l, r, x
INTEGER :: mid
IF (r >= l) THEN
    mid = l + (r - l)/2
    IF (arr(mid) == x) THEN
        res = mid
    ELSE IF (arr(mid) > x) THEN
        res = BSEARCH(arr, l, mid-1, x)
    ELSE
        res = BSEARCH(arr, mid+1, r, x)
    END IF
ELSE
    res = -1
END IF
END FUNCTION

! Working Principle:
! Divide-and-conquer approach
! Log(n) recursive calls
\end{verbatim}

\subsection*{6. Tower of Hanoi}
\begin{verbatim}
RECURSIVE SUBROUTINE HANOI(n, from, to, aux)
INTEGER, INTENT(IN) :: n
CHARACTER(*), INTENT(IN) :: from, to, aux
IF (n == 1) THEN
    PRINT *, "Move disk 1 from ", from, " to ", to
ELSE
    CALL HANOI(n-1, from, aux, to)
    PRINT *, "Move disk ", n, " from ", from, " to ", to
    CALL HANOI(n-1, aux, to, from)
END IF
END SUBROUTINE

! Working Principle:
! Moves n-1 disks to auxiliary tower
! Moves nth disk to target
! Recursively moves n-1 disks from auxiliary
\end{verbatim}

\subsection*{7. Palindrome Check}
\begin{verbatim}
RECURSIVE LOGICAL FUNCTION IS_PAL(str, l, r) RESULT(res)
CHARACTER(*), INTENT(IN) :: str
INTEGER, INTENT(IN) :: l, r
IF (l >= r) THEN
    res = .TRUE.
ELSE IF (str(l:l) /= str(r:r)) THEN
    res = .FALSE.
ELSE
    res = IS_PAL(str, l+1, r-1)
END IF
END FUNCTION

! Working Principle:
! Compares characters at both ends
! Moves toward center recursively
\end{verbatim}

\subsection*{8. Power Calculation}
\begin{verbatim}
RECURSIVE REAL FUNCTION POWER(x, n) RESULT(res)
REAL, INTENT(IN) :: x
INTEGER, INTENT(IN) :: n
IF (n == 0) THEN
    res = 1.0
ELSE IF (n > 0) THEN
    res = x * POWER(x, n-1)
ELSE
    res = 1.0 / POWER(x, -n)
END IF
END FUNCTION

! Working Principle:
! Handles positive/negative exponents
! Recursive multiplication/division
\end{verbatim}

\subsection*{9. Flood Fill Algorithm}
\begin{verbatim}
RECURSIVE SUBROUTINE FLOOD_FILL(grid, x, y, old, new)
INTEGER, INTENT(INOUT) :: grid(:,:)
INTEGER, INTENT(IN) :: x, y, old, new
IF (x < 1 .OR. x > SIZE(grid,1)) RETURN
IF (y < 1 .OR. y > SIZE(grid,2)) RETURN
IF (grid(x,y) /= old) RETURN

grid(x,y) = new
CALL FLOOD_FILL(grid, x+1, y, old, new)
CALL FLOOD_FILL(grid, x-1, y, old, new)
CALL FLOOD_FILL(grid, x, y+1, old, new)
CALL FLOOD_FILL(grid, x, y-1, old, new)
END SUBROUTINE

! Working Principle:
! 4-directional recursive filling
! Base cases: Boundary checks and color match
\end{verbatim}

\subsection*{10. String Reversal}
\begin{verbatim}
RECURSIVE SUBROUTINE REVERSE_STR(str, l, r)
CHARACTER(*), INTENT(INOUT) :: str
INTEGER, INTENT(IN) :: l, r
CHARACTER :: temp
IF (l < r) THEN
    temp = str(l:l)
    str(l:l) = str(r:r)
    str(r:r) = temp
    CALL REVERSE_STR(str, l+1, r-1)
END IF
END SUBROUTINE

! Working Principle:
! Swaps characters at ends and moves inward
! Terminates when pointers cross
\end{verbatim}

\subsection*{11. Linked List Traversal}
\begin{verbatim}
TYPE Node
INTEGER :: data
INTEGER :: next
END TYPE

RECURSIVE SUBROUTINE TRAVERSE(list, index)
TYPE(Node), INTENT(IN) :: list(:)
INTEGER, INTENT(IN) :: index
IF (index /= 0) THEN
    PRINT *, list(index)%data
    CALL TRAVERSE(list, list(index)%next)
END IF
END SUBROUTINE

! Working Principle:
! Recursive traversal using index pointers
! Simulates pointer-based recursion
\end{verbatim}

\subsection*{12. Tree Inorder Traversal}
\begin{verbatim}
TYPE TreeNode
INTEGER :: data
INTEGER :: left
INTEGER :: right
END TYPE

RECURSIVE SUBROUTINE INORDER(tree, root)
TYPE(TreeNode), INTENT(IN) :: tree(:)
INTEGER, INTENT(IN) :: root
IF (root /= 0) THEN
    CALL INORDER(tree, tree(root)%left)
    PRINT *, tree(root)%data
    CALL INORDER(tree, tree(root)%right)
END IF
END SUBROUTINE

! Working Principle:
! Visits left subtree â†’ root â†’ right subtree
! Recursive depth-first traversal
\end{verbatim}

\subsection*{13. Permutations Generation}
\begin{verbatim}
RECURSIVE SUBROUTINE PERMUTE(arr, l, r)
INTEGER, INTENT(INOUT) :: arr(:)
INTEGER, INTENT(IN) :: l, r
INTEGER :: i, temp
IF (l == r) THEN
    PRINT *, arr
ELSE
    DO i = l, r
        temp = arr(l)
        arr(l) = arr(i)
        arr(i) = temp
        CALL PERMUTE(arr, l+1, r)
        temp = arr(l)
        arr(l) = arr(i)
        arr(i) = temp
    END DO
END IF
END SUBROUTINE

! Working Principle:
! Heap's algorithm implementation
! Backtracking through recursive swaps
\end{verbatim}

\subsection*{14. Directory Traversal}
\begin{verbatim}
RECURSIVE SUBROUTINE LIST_DIR(path)
CHARACTER(*), INTENT(IN) :: path
CHARACTER(256) :: cmd, newpath
INTEGER :: status

CALL SYSTEM('ls '//TRIM(path)//' > dirlist.tmp')
OPEN(UNIT=10, FILE='dirlist.tmp', STATUS='OLD')
DO WHILE (.TRUE.)
    READ(10,*,IOSTAT=status) cmd
    IF (status /= 0) EXIT
    IF (cmd(1:1) == 'D') THEN
        newpath = TRIM(path)//'/'//cmd(3:)
        CALL LIST_DIR(TRIM(newpath))
    END IF
END DO
CLOSE(10, STATUS='DELETE')
END SUBROUTINE

! Working Principle:
! Recursive directory listing
! Uses system calls for directory detection
\end{verbatim}

\subsection*{15. Maze Solver}
\begin{verbatim}
RECURSIVE LOGICAL FUNCTION SOLVE_MAZE(maze, x, y) RESULT(res)
INTEGER, INTENT(INOUT) :: maze(:,:)
INTEGER, INTENT(IN) :: x, y

IF (x < 1 .OR. x > SIZE(maze,1)) THEN; res = .FALSE.; RETURN; END IF
IF (y < 1 .OR. y > SIZE(maze,2)) THEN; res = .FALSE.; RETURN; END IF

IF (maze(x,y) == 9) THEN; res = .TRUE.; RETURN; END IF
IF (maze(x,y) /= 0) THEN; res = .FALSE.; RETURN; END IF

maze(x,y) = 2  ! Mark path
res = SOLVE_MAZE(maze, x+1, y) .OR. SOLVE_MAZE(maze, x-1, y) &
    .OR. SOLVE_MAZE(maze, x, y+1) .OR. SOLVE_MAZE(maze, x, y-1)
IF (.NOT. res) maze(x,y) = 3  ! Mark dead end
END FUNCTION

! Working Principle:
! 4-directional path finding with backtracking
! Marks current path and dead ends
\end{verbatim}

\subsection*{Important Notes}
\begin{itemize}
\item All examples require compiler flags for recursion support
\item Actual Fortran 77 implementations need WORKAROUNDS for:
  \begin{itemize}
  \item Derived types (use arrays instead)
  \item Dynamic memory (use fixed-size arrays)
  \item System calls (implementation-dependent)
  \end{itemize}
\item Recursion depth limited by stack size
\item Iterative implementations preferred for production code
\end{itemize}

\section{Exercises: Recursion in Fortran 77}

\subsection*{Basic Recursion Concepts}  
1. **Factorial Function**:  
   Implement a recursive function `FACT(n)` to compute the factorial of a non-negative integer. Explain how the base case and recursive step work.  

2. **Fibonacci Sequence**:  
   Write a recursive function `FIB(n)` to return the nth Fibonacci number. Discuss the inefficiency of this approach and suggest an optimization.  

3. **Array Sum**:  
   Create a recursive function `ARRAY_SUM(arr, n)` to calculate the sum of elements in a 1D array. Specify the base case and recursion logic.  

4. **String Length**:  
   Design a recursive function `STRLEN(str)` to compute the length of a character string without using Fortran's intrinsic `LEN` function.  

\subsection*{Algorithmic Problems}  
5. **Greatest Common Divisor (GCD)**:  
   Implement Euclid's algorithm recursively in a function `GCD(a, b)`. Explain the mathematical basis for the recursive step.  

6. **Tower of Hanoi**:  
   Write a recursive subroutine `HANOI(n, source, target, auxiliary)` to solve the Tower of Hanoi problem for \( n \) disks. List the sequence of moves for \( n=3 \).  

7. **Binary Search**:  
   Develop a recursive function `BSEARCH(arr, low, high, key)` to perform binary search on a sorted array. State the time complexity.  

8. **Palindrome Check**:  
   Create a recursive logical function `IS_PAL(str, start, end)` to check if a substring is a palindrome. Handle empty strings and single characters.  

\subsection*{Advanced Applications}  
9. **Flood Fill Algorithm**:  
   Design a recursive subroutine `FLOOD_FILL(grid, x, y, old, new)` to implement the flood fill operation on a 2D grid. Specify boundary conditions.  

10. **Recursion Limitations**:  
    Convert the recursive factorial function from Exercise 1 into an iterative version. Discuss why iteration might be preferred in Fortran 77.  

\section{Exercise Answers: Recursion in Fortran 77}

\subsection*{1. Factorial Function}
\begin{verbatim}
C     RECURSIVE FACTORIAL FUNCTION
      RECURSIVE INTEGER FUNCTION FACT(N) RESULT(RES)
      INTEGER, INTENT(IN) :: N
      IF (N <= 0) THEN
          RES = 1  ! BASE CASE
      ELSE
          RES = N * FACT(N - 1)  ! RECURSIVE CASE
      END IF
      END FUNCTION

C     MAIN PROGRAM
      PROGRAM MAIN
      INTEGER :: NUM = 5
      WRITE(*,*) '5! = ', FACT(NUM)
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Base case: \( n \leq 0 \) returns 1  
- Recursive step: \( n \times fact(n-1) \)  
- Requires compiler flag: \texttt{-frecursive} in gfortran  
- Stack depth: \( O(n) \)

\subsection*{2. Fibonacci Sequence}
\begin{verbatim}
C     RECURSIVE FIBONACCI
      RECURSIVE INTEGER FUNCTION FIB(N) RESULT(RES)
      INTEGER, INTENT(IN) :: N
      IF (N <= 0) THEN
          RES = 0
      ELSE IF (N == 1) THEN
          RES = 1
      ELSE
          RES = FIB(N-1) + FIB(N-2)
      END IF
      END FUNCTION

C     MAIN PROGRAM
      PROGRAM MAIN
      WRITE(*,*) 'FIB(6) = ', FIB(6)  ! OUTPUT: 8
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Two base cases (\( n=0 \), \( n=1 \))  
- Exponential time complexity \( O(2^n) \)  
- Optimization: Use memoization or iteration  

\subsection*{3. Array Sum}
\begin{verbatim}
C     RECURSIVE ARRAY SUM
      RECURSIVE REAL FUNCTION ARRAY_SUM(ARR, N) RESULT(SUM)
      REAL, INTENT(IN) :: ARR(N)
      INTEGER, INTENT(IN) :: N
      IF (N == 0) THEN
          SUM = 0.0
      ELSE
          SUM = ARR(N) + ARRAY_SUM(ARR, N-1)
      END IF
      END FUNCTION

C     USAGE
      PROGRAM MAIN
      REAL :: A(5) = [1.0, 2.0, 3.0, 4.0, 5.0]
      WRITE(*,*) 'SUM = ', ARRAY_SUM(A,5)  ! 15.0
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Base case: Empty array (\( n=0 \)) returns 0  
- Recursive: Last element + sum of first \( n-1 \) elements  
- Stack depth equals array size  

\subsection*{4. String Length}
\begin{verbatim}
C     RECURSIVE STRING LENGTH
      RECURSIVE INTEGER FUNCTION STRLEN(STR) RESULT(LEN)
      CHARACTER(*), INTENT(IN) :: STR
      IF (STR(1:1) == ' ') THEN
          LEN = 0
      ELSE
          LEN = 1 + STRLEN(STR(2:))
      END IF
      END FUNCTION

C     MAIN PROGRAM
      PROGRAM MAIN
      WRITE(*,*) 'LENGTH = ', STRLEN('HELLO')  ! 5
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Base case: Empty character returns 0  
- Recursive: Count first character + process substring  
- Handles strings up to 32,767 characters (Fortran limit)  

\subsection*{5. Greatest Common Divisor (GCD)}
\begin{verbatim}
C     RECURSIVE GCD
      RECURSIVE INTEGER FUNCTION GCD(A,B) RESULT(RES)
      INTEGER, INTENT(IN) :: A, B
      IF (B == 0) THEN
          RES = A
      ELSE
          RES = GCD(B, MOD(A,B))
      END IF
      END FUNCTION

C     USAGE
      PROGRAM MAIN
      WRITE(*,*) 'GCD(48,18) = ', GCD(48,18)  ! 6
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Base case: \( b = 0 \) returns \( a \)  
- Recursive: \( gcd(b, a \mod b) \)  
- Implements Euclid's algorithm  

\subsection*{6. Tower of Hanoi}
\begin{verbatim}
C     RECURSIVE HANOI SOLUTION
      RECURSIVE SUBROUTINE HANOI(N, FROM, TO, AUX)
      INTEGER, INTENT(IN) :: N
      CHARACTER(*), INTENT(IN) :: FROM, TO, AUX
      IF (N == 1) THEN
          WRITE(*,*) 'Move disk 1 from ', FROM, ' to ', TO
      ELSE
          CALL HANOI(N-1, FROM, AUX, TO)
          WRITE(*,*) 'Move disk ', N, ' from ', FROM, ' to ', TO
          CALL HANOI(N-1, AUX, TO, FROM)
      END IF
      END SUBROUTINE

C     MAIN PROGRAM
      PROGRAM MAIN
      CALL HANOI(3, 'A', 'C', 'B')
      STOP
      END
\end{verbatim}
\textbf{Output for n=3:}  
1. Move disk 1 from A to C  
2. Move disk 2 from A to B  
3. Move disk 1 from C to B  
4. Move disk 3 from A to C  
5. Move disk 1 from B to A  
6. Move disk 2 from B to C  
7. Move disk 1 from A to C  

\subsection*{7. Binary Search}
\begin{verbatim}
C     RECURSIVE BINARY SEARCH
      RECURSIVE INTEGER FUNCTION BSEARCH(ARR, L, R, X) RESULT(INDEX)
      INTEGER, INTENT(IN) :: ARR(*), L, R, X
      INTEGER :: MID
      IF (R >= L) THEN
          MID = L + (R - L)/2
          IF (ARR(MID) == X) THEN
              INDEX = MID
          ELSE IF (ARR(MID) > X) THEN
              INDEX = BSEARCH(ARR, L, MID-1, X)
          ELSE
              INDEX = BSEARCH(ARR, MID+1, R, X)
          END IF
      ELSE
          INDEX = -1
      END IF
      END FUNCTION
\end{verbatim}
\textbf{Explanation:}  
- Time complexity: \( O(\log n) \)  
- Space complexity: \( O(\log n) \) (recursive stack)  
- Precondition: Array must be sorted  

\subsection*{8. Palindrome Check}
\begin{verbatim}
C     RECURSIVE PALINDROME CHECK
      RECURSIVE LOGICAL FUNCTION IS_PAL(STR, L, R) RESULT(RES)
      CHARACTER(*), INTENT(IN) :: STR
      INTEGER, INTENT(IN) :: L, R
      IF (L >= R) THEN
          RES = .TRUE.
      ELSE IF (STR(L:L) /= STR(R:R)) THEN
          RES = .FALSE.
      ELSE
          RES = IS_PAL(STR, L+1, R-1)
      END IF
      END FUNCTION

C     USAGE
      PROGRAM MAIN
      CHARACTER(5) :: S = 'LEVEL'
      WRITE(*,*) IS_PAL(S, 1, LEN_TRIM(S))  ! .TRUE.
      STOP
      END
\end{verbatim}
\textbf{Explanation:}  
- Base case: \( l \geq r \) (empty or single-character string)  
- Recursive: Compare ends and check inner substring  

\subsection*{9. Flood Fill Algorithm}
\begin{verbatim}
C     RECURSIVE FLOOD FILL
      RECURSIVE SUBROUTINE FLOOD_FILL(GRID, X, Y, OLD, NEW)
      INTEGER, INTENT(INOUT) :: GRID(:,:)
      INTEGER, INTENT(IN) :: X, Y, OLD, NEW
      IF (X < 1 .OR. X > SIZE(GRID,1)) RETURN
      IF (Y < 1 .OR. Y > SIZE(GRID,2)) RETURN
      IF (GRID(X,Y) /= OLD) RETURN

      GRID(X,Y) = NEW
      CALL FLOOD_FILL(GRID, X+1, Y, OLD, NEW)
      CALL FLOOD_FILL(GRID, X-1, Y, OLD, NEW)
      CALL FLOOD_FILL(GRID, X, Y+1, OLD, NEW)
      CALL FLOOD_FILL(GRID, X, Y-1, OLD, NEW)
      END SUBROUTINE
\end{verbatim}
\textbf{Explanation:}  
- Base cases: Out-of-bounds or different color  
- 4-directional recursion  
- Marks visited cells to prevent infinite loops  

\subsection*{10. Iterative Factorial}
\begin{verbatim}
C     ITERATIVE FACTORIAL
      INTEGER FUNCTION ITER_FACT(N)
      INTEGER, INTENT(IN) :: N
      INTEGER :: I
      ITER_FACT = 1
      DO 10 I = 1, N
          ITER_FACT = ITER_FACT * I
10    CONTINUE
      END FUNCTION
\end{verbatim}
\textbf{Comparison:}  
- No stack overflow risk  
- Constant \( O(1) \) space vs recursive \( O(n) \)  
- Faster execution (no function call overhead)  

\end{document}

\end{document}
